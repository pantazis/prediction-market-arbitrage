{
  "codebase_operations": {
    "version": "2.0",
    "generated": "2026-01-07",
    "project": "prediction-market-arbitrage",
    "description": "Complete operational reference for running, testing, simulating, and controlling the arbitrage bot",
    "section": "ALL_OPERATIONS",
    "run_commands": {
      "main_cli": {
        "entry": "src/predarb/__main__.py",
        "class": "cli.main()",
        "commands": [
          {
            "cmd": "python -m predarb run",
            "mode": "run",
            "description": "Start infinite loop: detect arbs ‚Üí execute trades ‚Üí sleep ‚Üí repeat",
            "config": "Reads config.yml (can override with --config PATH)",
            "iterations": "Infinite (--iterations N to set limit)",
            "env_requirements": ["POLYMARKET_API_KEY", "POLYMARKET_SECRET", "POLYMARKET_PASSPHRASE"],
            "output": "Logs to stdout + writes reports/paper_trades.csv + sends Telegram notifications (if enabled)",
            "when_to_use": "Production / continuous monitoring"
          },
          {
            "cmd": "python -m predarb once",
            "mode": "once",
            "description": "Run single iteration: detect arbs ‚Üí execute trades ‚Üí exit",
            "config": "Reads config.yml",
            "output": "Logs to stdout + writes to CSV + Telegram notification",
            "when_to_use": "Quick test, cron job, one-shot analysis"
          },
          {
            "cmd": "python demo_unified_reporting.py",
            "mode": "demo",
            "description": "Run UnifiedReporter demo to generate reports/unified_report.json without APIs",
            "output": "Creates reports/unified_report.json with iteration summary and opportunity logs",
            "when_to_use": "Sanity-check unified reporting locally"
          },
          {
            "cmd": "python -m predarb selftest",
            "mode": "selftest",
            "description": "Run against fixture data (no API calls, deterministic)",
            "config": "Uses test fixtures from tests/fixtures/markets.json",
            "env_requirements": "None (fixtures included)",
            "output": "Logs validation results, exits immediately",
            "when_to_use": "Verify code works without API, CI/CD pipeline"
          },
          {
            "cmd": "python -m predarb stress",
            "mode": "stress",
            "description": "DRY-RUN stress test with injectable market data (no network calls)",
            "injection_sources": [
              "scenario:<name> - built-in stress scenarios",
              "file:<path> - JSON fixture file",
              "inline:<json> - inline JSON payload"
            ],
            "arguments": [
              {
                "arg": "--scenario NAME",
                "description": "Use built-in stress scenario (shorthand for --inject scenario:NAME)",
                "examples": ["high_volume", "many_risk_rejections", "partial_fill", "happy_path", "latency_freshness", "fee_slippage", "semantic_clustering"]
              },
              {
                "arg": "--inject SPEC",
                "description": "Full injection spec: scenario:<name> | file:<path> | inline:<json>",
                "examples": [
                  "scenario:happy_path",
                  "file:tests/fixtures/markets.json",
                  "inline:[{\"id\":\"m1\",\"question\":\"Test?\",\"outcomes\":[...]}]"
                ]
              },
              {
                "arg": "--iterations N",
                "default": 1,
                "description": "Number of stress test iterations (default: 1)"
              },
              {
                "arg": "--seed N",
                "default": 42,
                "description": "Random seed for reproducible scenario generation"
              },
              {
                "arg": "--no-verify",
                "description": "Skip automatic report verification after stress test"
              },
              {
                "arg": "--config PATH",
                "description": "Custom config.yml (default: config.yml)"
              }
            ],
            "example_commands": [
              "python -m predarb stress --scenario happy_path (quick smoke test)",
              "python -m predarb stress --scenario high_volume --iterations 10 (stress with 1000 markets)",
              "python -m predarb stress --inject file:tests/fixtures/markets.json --seed 999",
              "python -m predarb stress --scenario partial_fill --no-verify (skip verification)"
            ],
            "exit_codes": {
              "0": "All checks passed (after auto-verification)",
              "1": "General error or user interrupt",
              "2": "Report file missing or unreadable",
              "3": "Report schema invalid (malformed JSON or missing keys)",
              "4": "No iterations recorded (unexpected empty report)",
              "5": "Expected executions/trades missing (data inconsistency)",
              "6": "Invariants failed (residual exposure not hedged, etc.)"
            },
            "stress_scenarios": {
              "high_volume": {
                "markets": 1000,
                "description": "990 normal markets + 10 arbitrage opportunities",
                "tests": "Performance and filtering efficiency"
              },
              "many_risk_rejections": {
                "markets": 40,
                "description": "20 low liquidity + 15 low edge + 5 good opportunities",
                "tests": "Risk manager validation and rejection handling"
              },
              "partial_fill": {
                "markets": 10,
                "description": "Asymmetric liquidity (deep YES, shallow NO)",
                "tests": "Hedge/cancel logic on execution failure"
              },
              "happy_path": {
                "markets": 15,
                "description": "Strong arbitrage opportunities with clean execution",
                "tests": "Success case end-to-end with realized P&L"
              },
              "latency_freshness": {
                "markets": 15,
                "description": "10 expiring soon + 5 fresh markets",
                "tests": "Expiry validation and freshness checks"
              },
              "fee_slippage": {
                "markets": 20,
                "description": "Marginal opportunities where fees/slippage eliminate edge",
                "tests": "Cost modeling and rejection"
              },
              "semantic_clustering": {
                "markets": 25,
                "description": "Markets with semantic duplicates (BTC/Bitcoin, Democrat variations) + filter violations (spread, volume, liquidity, expiry, resolution source) + distinct entities",
                "tests": "Semantic clustering with sentence-transformers, duplicate detection, all filter criteria (spread, volume, liquidity, expiry, resolution_source)"
              }
            },
            "flow": [
              "1. Parse injection spec (scenario/file/inline)",
              "2. Create injected market provider (seeded, deterministic)",
              "3. Replace Engine.client with injected provider",
              "4. Run stress test (run_once or run loop)",
              "5. Auto-verify reports/unified_report.json (unless --no-verify)",
              "6. Exit with verification exit code"
            ],
            "output": "reports/unified_report.json + stdout logs",
            "when_to_use": "CI/CD pipeline, pre-deployment validation, regression testing, stress testing filtering/risk/hedging logic",
            "env_requirements": "None (no network calls, uses injected data)"
          }
        ],
        "config_override": {
          "syntax": "python -m predarb [run|once|selftest|stress] --config /path/to/config.yml",
          "example": "python -m predarb stress --scenario happy_path --config my_config.yml"
        }
      },
      "verification": {
        "entry": "src/predarb/verify_reports.py",
        "cli": "python -m predarb.verify_reports [--report PATH] [--quiet]",
        "description": "Verify unified_report.json structure, completeness, and invariants",
        "arguments": [
          {
            "arg": "--report PATH",
            "default": "reports/unified_report.json",
            "description": "Path to unified report file"
          },
          {
            "arg": "-q, --quiet",
            "description": "Suppress summary output (return exit code only)"
          }
        ],
        "checks": [
          "File exists and readable",
          "Valid JSON with required schema",
          "Metadata section present",
          "At least one iteration recorded",
          "Execution/trade data consistency",
          "Invariants: residual exposure hedged, non-success has hedge, etc."
        ],
        "exit_codes": {
          "0": "OK - all checks passed",
          "2": "Report file missing or unreadable",
          "3": "Invalid schema (malformed JSON or missing keys)",
          "4": "No iterations recorded",
          "5": "Expected executions/trades missing",
          "6": "Invariants failed (hedge/flatten logic violated)"
        },
        "example_commands": [
          "python -m predarb.verify_reports (verify default report)",
          "python -m predarb.verify_reports --report custom/path.json",
          "python -m predarb.verify_reports --quiet (exit code only)",
          "echo $? (check exit code on Unix)",
          "$LASTEXITCODE (check exit code on Windows PowerShell)"
        ],
        "when_to_use": "Post-run validation, CI/CD pipeline checks, debugging report issues"
      },
      "simulation": {
        "entry": "sim_run.py",
        "call": "python sim_run.py",
        "description": "Run bot against FAKE Polymarket client with REAL Telegram notifications",
        "when_to_use": "Test without hitting live API, realistic E2E validation",
        "arguments": [
          {
            "arg": "--days N",
            "default": 5,
            "description": "Simulate N days of market evolution"
          },
          {
            "arg": "--trade-size N",
            "default": 100,
            "description": "Size per trade in USD"
          },
          {
            "arg": "--seed N",
            "default": 42,
            "description": "Random seed for reproducibility"
          },
          {
            "arg": "--markets N",
            "default": 50,
            "description": "Generate N synthetic markets"
          },
          {
            "arg": "--config PATH",
            "description": "Custom config.yml"
          },
          {
            "arg": "--no-telegram",
            "description": "Disable Telegram notifications (mock instead)"
          },
          {
            "arg": "-v/--verbose",
            "description": "Print debug output"
          }
        ],
        "example_flows": [
          "python sim_run.py --days 2 --trade-size 200 (simulate 2 days, $200/trade, real Telegram)",
          "python sim_run.py --days 7 --no-telegram (7-day sim, no Telegram)",
          "python sim_run.py --seed 999 --markets 100 (100 markets, fixed seed)"
        ],
        "how_it_works": [
          "1. Generates synthetic markets (FakePolymarketClient)",
          "2. Engine.run_once() called iteratively (days * iterations per day)",
          "3. Markets evolve minute-by-minute (prices change, trades happen)",
          "4. Detectors run, opportunities detected",
          "5. Broker executes trades (paper trading)",
          "6. TelegramNotifier sends real messages (unless --no-telegram)",
          "7. Final report with P&L, Sharpe ratio, max drawdown"
        ]
      },
      "utilities": [
        {
          "script": "python check_connection.py",
          "purpose": "Test Polymarket API connectivity (GET /markets)"
        },
        {
          "script": "python get_keys.py",
          "purpose": "Retrieve/manage API keys"
          },
          {
            "script": "python -c \"from src.predarb.unified_reporter import read_unified_report; data = read_unified_report(); print(f'Iterations: {len(data.get(\\\"iterations\\\", []))}, Opportunities: {len(data.get(\\\"opportunity_executions\\\", []))}')\"",
            "purpose": "Read and summarize reports/unified_report.json (unified JSON reporting)",
            "notes": "No network calls; replaces legacy CSV reading"
          },
          {
            "script": "python -c \"from src.predarb.unified_reporter import export_legacy_csv; export_legacy_csv()\"",
            "purpose": "Export legacy CSV files from unified_report.json for backward compatibility",
            "notes": "Generates live_summary.csv and paper_trades.csv from unified JSON"
        }
      ]
    },
    "test_commands": {
      "run_all_tests": {
        "cmd": "pytest tests/",
        "description": "Run entire test suite"
      },
      "test_by_category": [
        {
          "category": "Unified Reporting (JSON-based)",
          "cmd": "python -m pytest -q tests/test_unified_reporter.py",
          "coverage": "23 tests covering UnifiedReporter initialization, iteration logging, opportunity execution logging, JSON structure, file safety, legacy export"
        },
        {
          "category": "Legacy Live Reporting (CSV-based, deprecated)",
          "cmd": "python -m pytest -q tests/test_reporter.py",
          "coverage": "10 tests covering initialization, deduplication, state persistence, order-independence, CSV format",
          "note": "Legacy reporter - UnifiedReporter is the current implementation"
        },
        {
          "category": "Engine & Core Logic",
          "cmd": "pytest tests/test_engine.py tests/test_broker.py tests/test_detectors.py -v"
        },
        {
          "category": "Telegram Commands (parsing, auth, routing)",
          "cmd": "pytest tests/test_telegram_interface.py -v",
          "coverage": "27 tests covering command parsing, rate limiting, authorization, handlers"
        },
        {
          "category": "Telegram Notifications (app‚Üíuser messages)",
          "cmd": "pytest tests/test_telegram_notifier.py -v",
          "note": "Legacy module - use test_simulation_harness.py for modern impl"
        },
        {
          "category": "Simulation & Mocks (FakeClient, TelegramMock)",
          "cmd": "pytest tests/test_simulation_harness.py -v",
          "coverage": "34 tests covering synthetic markets, mock client, notifier mocking"
        },
        {
          "category": "Invariant Tests (comprehensive correctness proofs)",
          "cmd": "pytest tests/test_*_invariants.py -v",
          "coverage": "215+ tests validating market data, filtering, detectors, broker, risk (16 invariants)"
        },
        {
          "category": "Full Suite with Coverage",
          "cmd": "pytest tests/ --cov=src/predarb --cov=arbitrage_bot --cov-report=html"
        }
      ],
      "specific_test_examples": [
        {
          "name": "Run reporter tests (quiet)",
          "cmd": "python -m pytest -q tests/test_reporter.py --junitxml=reports/reporter-tests.xml"
        },
        {
          "name": "Run reporter tests (verbose)",
          "cmd": "python -m pytest tests/test_reporter.py -v"
        },
        {
          "name": "Test command parsing",
          "cmd": "pytest tests/test_telegram_interface.py::TestCommandParser -v"
        },
        {
          "name": "Test rate limiting",
          "cmd": "pytest tests/test_telegram_interface.py::TestRateLimiter -v"
        },
        {
          "name": "Test authorization",
          "cmd": "pytest tests/test_telegram_interface.py::TestAuthorizationGate -v"
        },
        {
          "name": "Test handler logic",
          "cmd": "pytest tests/test_telegram_interface.py::TestTelegramHandlers -v"
        },
        {
          "name": "Test simulation integration",
          "cmd": "pytest tests/test_simulation_harness.py::TestSimulationIntegration -v"
        },
        {
          "name": "Test LLM verification",
          "cmd": "pytest tests/test_llm_verifier.py -v"
        }
      ]
    },
    "llm_verification": {
      "description": "Optional LLM-based verification layer for semantic market clustering. Confirms two markets truly resolve on the same event + criteria.",
      "purpose": "Reduce false positives from embeddings (e.g., 'Fed holds in January' vs 'Fed holds in March')",
      "enabled_by_default": false,
      "configuration": {
        "location": "config.yml under 'llm_verification' section",
        "fields": {
          "enabled": {
            "type": "bool",
            "default": false,
            "description": "Enable/disable LLM verification"
          },
          "provider": {
            "type": "str",
            "default": "mock",
            "options": ["mock", "openai", "gemini"],
            "description": "LLM provider to use. 'mock' for testing (no API calls), 'openai' for GPT-3.5"
          },
          "model": {
            "type": "str",
            "default": "gpt-3.5-turbo",
            "description": "Model name (e.g., 'gpt-3.5-turbo', 'gemini-1.5-flash')"
          },
          "timeout_s": {
            "type": "float",
            "default": 3.0,
            "description": "Timeout per verification call in seconds"
          },
          "max_pairs_per_group": {
            "type": "int",
            "default": 5,
            "description": "Max market pairs to verify per semantic group"
          },
          "min_similarity_to_verify": {
            "type": "float",
            "default": 0.90,
            "description": "Only verify pairs with embedding similarity >= this (0..1)"
          },
          "cache_path": {
            "type": "str",
            "default": "data/llm_verify_cache.json",
            "description": "Path to persistent cache (write-then-rename for safety)"
          },
          "ttl_hours": {
            "type": "int",
            "default": 168,
            "description": "Cache TTL in hours (default: 1 week)"
          },
          "fail_mode": {
            "type": "str",
            "default": "fail_open",
            "options": ["fail_open", "fail_closed"],
            "description": "On timeout/error: 'fail_open'=assume same event, 'fail_closed'=assume different"
          }
        }
      },
      "yaml_example": "llm_verification:\n  enabled: true\n  provider: openai\n  model: gpt-3.5-turbo\n  timeout_s: 3.0\n  max_pairs_per_group: 5\n  fail_mode: fail_open",
      "environment_requirements": {
        "openai_provider": "Set OPENAI_API_KEY env var for GPT-3.5 verification",
        "mock_provider": "No API key needed; deterministic testing"
      },
      "components": {
        "LLMVerifierConfig": {
          "location": "src/predarb/config.py",
          "description": "Configuration Pydantic model with validation"
        },
        "LLMVerifier": {
          "location": "src/predarb/llm_verifier.py",
          "methods": {
            "verify_pair(market_a, market_b)": "Verify if two markets are same event; returns VerificationResult with confidence",
            "verify_group(group)": "Verify all pairs in a market group; uses union-find to split into subgroups"
          }
        },
        "VerificationResult": {
          "description": "Result of verifying two markets",
          "fields": ["same_event (bool)", "confidence (0..1)", "reason (str)", "resolution_source (optional)", "resolution_date (optional)"]
        },
        "LLMProvider": {
          "description": "Abstract interface for LLM backends",
          "implementations": ["OpenAIChatProvider (real API)", "MockLLMProvider (deterministic testing)"]
        }
      },
      "integration": {
        "location": "src/predarb/matchers.py::verify_semantic_groups()",
        "trigger": "After semantic clustering groups markets",
        "input": "Dict[group_id -> List[Market]] from semantic clustering",
        "output": "Dict[group_id -> List[List[Market]]] with verified subgroups",
        "example_usage": "verified = verify_semantic_groups(semantic_groups, llm_verifier=verifier)"
      },
      "caching": {
        "strategy": "Persistent JSON cache with TTL",
        "cache_key": "hash(sorted_market_ids, prompt_version, model_name)",
        "order_invariant": "Pair (a,b) and (b,a) have same cache key",
        "write_safety": "Write to temp file then atomic rename to avoid corruption"
      },
      "testing": {
        "cmd": "pytest tests/test_llm_verifier.py -v",
        "coverage": "34 tests with MockLLMProvider (zero network calls)",
        "test_scenarios": [
          "Same-event detection (Fed January)",
          "Different-event detection (January vs March)",
          "Cache hit prevention of duplicate calls",
          "Timeout with fail_open/fail_closed",
          "JSON parse error handling",
          "Cache persistence and TTL",
          "Group verification with union-find"
        ]
      },
      "production_notes": {
        "cost": "GPT-3.5 ~$0.0005 per call; with caching, typically 1-5 calls per bot run",
        "latency": "~0.5-1.5s per call; timeout_s default is 3.0, non-blocking with fail_open",
        "network_safe": "Timeouts are caught; bot continues if verification unavailable",
        "recommended": "Enable on production clusters; disable (default) for local testing"
      }
    },
    "live_mode": {
      "overview": "ENABLED by PaperBroker (simulation only); TO ENABLE REAL TRADING, requires code modification",
      "current_state": "All trades simulated via PaperBroker (no real capital/blockchain)",
      "simulation_features": [
        "Fee modeling (configurable bps)",
        "Slippage modeling (configurable bps)",
        "Liquidity constraints (depth_fraction)",
        "Position tracking and P&L"
      ],
      "to_enable_real_live": [
        "1. Replace PaperBroker with RealBroker (uses py-clob-client)",
        "2. Add private key management (eth-account)",
        "3. Add risk guardrails (kill switch, position limits)",
        "4. Test on testnet first (chain_id=1)",
        "5. Deploy on mainnet (chain_id=137)"
      ],
      "caution": "‚ö†Ô∏è REAL TRADING REQUIRES: API keys, private keys, significant capital, risk management expertise"
    },
    "server_runbook": {
      "document": "RUNBOOK_SERVER.md",
      "purpose": "Operational steps to stop previously running bots, verify health, and start the new bot on server",
      "stop_previous": {
        "systemd": [
          "sudo systemctl stop arbitrage-bot.service",
          "sudo systemctl disable arbitrage-bot.service (optional)",
          "sudo systemctl status arbitrage-bot.service"
        ],
        "tmux": [
          "tmux ls",
          "tmux kill-session -t arbitrage"
        ],
        "screen": [
          "screen -ls",
          "screen -S arbitrage -X quit"
        ],
        "docker": [
          "docker ps",
          "docker stop arbitrage-bot"
        ],
        "bare_process": [
          "ps aux | grep -E 'python (-m predarb|bot.py)' | grep -v grep",
          "pkill -f 'python -m predarb'",
          "pkill -f 'python bot.py'"
        ]
      },
      "verification": {
        "no_network": [
          ". .venv/bin/activate",
          "python -m predarb selftest",
          "pytest -q tests/test_reporter.py"
        ],
        "optional_network": [
          "python bot.py test_connection --config config.yml"
        ]
      },
      "start_new": {
        "venv_foreground": [
          ". .venv/bin/activate",
          "python -m predarb run --config config.yml"
        ],
        "venv_smoke": [
          "python -m predarb run --config config.yml --iterations 5"
        ],
        "tmux_background": [
          "tmux new -s arbitrage -d '. .venv/bin/activate && python -m predarb run --config config.yml'"
        ],
        "systemd": {
          "unit_path": "/etc/systemd/system/arbitrage-bot.service",
          "unit_template": "See RUNBOOK_SERVER.md",
          "enable_and_start": [
            "sudo systemctl daemon-reload",
            "sudo systemctl enable arbitrage-bot.service",
            "sudo systemctl start arbitrage-bot.service",
            "sudo systemctl status arbitrage-bot.service"
          ]
        }
      },
      "monitoring": {
        "logs": [
          "journalctl -u arbitrage-bot -f (systemd)",
          "tmux attach -t arbitrage (tmux)"
        ],
        "reports": [
          "reports/paper_trades.csv",
          "reports/live_summary.csv"
        ]
      }
    },
    "telegram_integration": {
      "overview": "Bidirectional bot-user communication: OUTBOUND (bot‚Üíuser notifications) + INBOUND (user‚Üíbot commands)",
      "architecture": "Freqtrade-style: Handlers queue actions (non-blocking), bot_loop processes async",
      "enable_telegram": {
        "step_1": "Create Telegram bot via @BotFather (get TELEGRAM_BOT_TOKEN)",
        "step_2": "Find your chat ID (use /tg_info command to find, or use bot getter)",
        "step_3": "Set environment variables or config.yml:",
        "env_vars": {
          "TELEGRAM_ENABLED": "true",
          "TELEGRAM_BOT_TOKEN": "123456789:ABCdefGHIjklmnoPQRstuvWXYZabcdefg",
          "TELEGRAM_CHAT_ID": "987654321"
        },
        "config_yaml": "telegram:\n  enabled: true\n  bot_token: \"${TELEGRAM_BOT_TOKEN}\"\n  chat_id: \"${TELEGRAM_CHAT_ID}\""
      },
      "outbound_messages": {
        "description": "Bot sends these messages to user",
        "message_types": [
          {
            "type": "trade_entered",
            "trigger": "Opportunity executed, position opened",
            "format": "üìä Market: [name]\nOutcomes: [YES/NO]\nSizes: [x units], [y units]\nPrices: [price1], [price2]\nExpected Edge: [%]"
          },
          {
            "type": "trade_exited",
            "trigger": "Position closed, P&L realized",
            "format": "‚úÖ CLOSED\nMarket: [name]\nP&L: $[amount] ([%] return)\nExit Price: [price]"
          },
          {
            "type": "daily_summary",
            "trigger": "End of day or /daily command",
            "format": "üìà Daily Summary\nTotal P&L: $[amount]\nRealized: $[amount]\nUnrealized: $[amount]\nReturn: [%]"
          },
          {
            "type": "status_reply",
            "trigger": "/status command",
            "format": "ü§ñ Bot Status\nState: [RUNNING/PAUSED/STOPPED]\nMode: [PAPER/LIVE/SCAN_ONLY]\nBalance: $[amount]\nPositions: [count]\nP&L: $[amount]"
          },
          {
            "type": "mode_changed",
            "trigger": "Operating mode changed",
            "format": "üîÑ Mode Changed\nPrevious: [old_mode]\nNew: [new_mode]\nTimestamp: [time]"
          },
          {
            "type": "error_alert",
            "trigger": "API error, invalid data, risk violation",
            "format": "‚ùå ERROR\nMessage: [error_text]\nTimestamp: [time]\nAction: [retry/halt/etc]"
          },
          {
            "type": "risk_warning",
            "trigger": "Kill switch triggered, drawdown exceeded, position limit breached",
            "format": "üö® CRITICAL - TRADING HALTED\nReason: [kill_switch/drawdown/limit]\nCurrent Loss: [%]\nThreshold: [%]"
          }
        ],
        "testing_outbound": "pytest tests/test_simulation_harness.py::TestTelegramNotifierReal -v"
      },
      "inbound_commands": {
        "description": "User sends /commands to bot, bot processes them",
        "flow": "Parse ‚Üí RateLimit ‚Üí Authorize ‚Üí Queue ‚Üí Return Response ‚Üí bot_loop executes async",
        "command_reference": [
          {
            "command": "/start",
            "category": "CONTROL",
            "permission": "execute_action",
            "args": "none",
            "effect": "Start bot (state=RUNNING)",
            "response": "‚úÖ Bot starting...",
            "rate_limit": "5/min (CONTROL)"
          },
          {
            "command": "/pause",
            "category": "CONTROL",
            "permission": "execute_action",
            "args": "none",
            "effect": "Pause bot (state=PAUSED, no new trades)",
            "response": "‚è∏Ô∏è Bot paused",
            "rate_limit": "5/min"
          },
          {
            "command": "/stop",
            "category": "CONTROL",
            "permission": "execute_action",
            "args": "none",
            "effect": "Stop bot (state=STOPPED, exit loop)",
            "response": "‚èπÔ∏è Bot stopped",
            "rate_limit": "5/min"
          },
          {
            "command": "/status",
            "category": "VIEW",
            "permission": "read_status",
            "args": "none",
            "effect": "Return bot state snapshot",
            "response": "Bot state, mode, balance, positions, P&L",
            "rate_limit": "10/min (VIEW)"
          },
          {
            "command": "/mode [scan-only|paper|live]",
            "category": "DANGEROUS",
            "permission": "execute_action + admin",
            "args": "scan-only, paper, or live",
            "effect": "Change operating mode (requires 2-step confirmation if live)",
            "response": "üîÑ Mode changed to [mode]",
            "rate_limit": "2/min (DANGEROUS)",
            "confirmation": true
          },
          {
            "command": "/daily",
            "category": "VIEW",
            "permission": "read_status",
            "args": "none",
            "effect": "Return daily P&L summary",
            "response": "Daily breakdown (realized, unrealized, total return)",
            "rate_limit": "10/min"
          },
          {
            "command": "/balance",
            "category": "VIEW",
            "permission": "read_status",
            "args": "none",
            "effect": "Show current balance and equity",
            "response": "Cash: $[amount], Equity: $[amount]",
            "rate_limit": "10/min"
          },
          {
            "command": "/positions",
            "category": "VIEW",
            "permission": "read_status",
            "args": "none",
            "effect": "List all open positions",
            "response": "Market: [name], Size: [units], Entry: $[price], Unrealized: $[pnl]",
            "rate_limit": "10/min"
          },
          {
            "command": "/freeze [all|venue|event]",
            "category": "CONTROL",
            "permission": "execute_action",
            "args": "all (freeze all trading) or venue/event (specific)",
            "effect": "Stop entering new positions (can still close existing)",
            "response": "üîí Frozen: [target]",
            "rate_limit": "5/min"
          },
          {
            "command": "/unfreeze [all|venue|event]",
            "category": "CONTROL",
            "permission": "execute_action",
            "args": "all or specific",
            "effect": "Resume entering new positions",
            "response": "üîì Unfrozen: [target]",
            "rate_limit": "5/min"
          },
          {
            "command": "/forceclose [all|market_id]",
            "category": "DANGEROUS",
            "permission": "execute_action + admin",
            "args": "all (close all positions) or market_id (close specific)",
            "effect": "Immediately close positions (2-step confirmation required)",
            "response": "üî¥ Closed [count] positions, realized P&L: $[amount]",
            "rate_limit": "2/min",
            "confirmation": true
          },
          {
            "command": "/help",
            "category": "VIEW",
            "permission": "read_status",
            "args": "none",
            "effect": "Show command help",
            "response": "List of available commands with descriptions",
            "rate_limit": "10/min"
          },
          {
            "command": "/confirm [code]",
            "category": "CONFIRMATION",
            "permission": "execute_action",
            "args": "6-digit confirmation code (received from dangerous command)",
            "effect": "Verify and execute dangerous command",
            "response": "‚úÖ Confirmed. Action executing..." or "‚ùå Invalid code",
            "rate_limit": "20/min"
          },
          {
            "command": "/tg_info",
            "category": "DEBUG",
            "permission": "read_status",
            "args": "none",
            "effect": "Echo chat_id and user_id (helps with setup)",
            "response": "Your chat_id: [id], user_id: [id]",
            "rate_limit": "10/min"
          },
          {
            "command": "/health",
            "category": "VIEW",
            "permission": "read_status",
            "args": "none",
            "effect": "Check API connectivity and system health",
            "response": "API: ‚úÖ OK, Memory: [usage], Uptime: [duration]",
            "rate_limit": "10/min"
          },
          {
            "command": "/opps",
            "category": "DEBUG",
            "permission": "read_status",
            "args": "none",
            "effect": "List current detected opportunities",
            "response": "Found [count] opportunities:\n[detector]: [market] - edge [%]",
            "rate_limit": "10/min"
          }
        ],
        "testing_inbound": "pytest tests/test_telegram_interface.py -v"
      },
      "security_features": {
        "authorization": [
          "Chat ID validation (must match TELEGRAM_CHAT_ID config)",
          "Role-based access control (read_status, execute_action, admin)",
          "VIEW commands: anyone with read_status",
          "CONTROL commands: requires execute_action",
          "DANGEROUS commands: requires execute_action + admin + 2-step confirmation"
        ],
        "confirmation": [
          "Dangerous commands (/mode live, /forceclose) require 2-step confirmation",
          "Command sends confirmation code (e.g., /confirm ABC123)",
          "User replies /confirm ABC123 to execute",
          "Code expires after 5 minutes (configurable)",
          "Each code is single-use"
        ],
        "rate_limiting": [
          "VIEW commands: 10/min per user",
          "CONTROL commands: 5/min per user",
          "DANGEROUS commands: 2/min per user",
          "CONFIRMATION: 20/min per user",
          "Global command queue prevents spam"
        ],
        "message_safety": [
          "Numbers formatted as strings (prevent precision loss)",
          "Markdown special chars escaped (prevent injection)",
          "Message length limited to 4096 (Telegram limit)",
          "User input sanitized",
          "All actions logged for audit trail"
        ]
      },
      "configuration": {
        "file": "config.yml",
        "section": "telegram",
        "schema": {
          "enabled": "bool (default: false)",
          "bot_token": "str (required if enabled, from @BotFather)",
          "chat_id": "int (required if enabled, your chat ID)",
          "auth": {
            "users": [
              {
                "user_id": "int",
                "roles": ["read_status", "execute_action", "admin"]
              }
            ]
          },
          "rate_limits": {
            "view": "int (commands/min, default: 10)",
            "control": "int (default: 5)",
            "dangerous": "int (default: 2)"
          }
        },
        "example_config": {
          "yaml": "telegram:\n  enabled: true\n  bot_token: \"${TELEGRAM_BOT_TOKEN}\"\n  chat_id: \"${TELEGRAM_CHAT_ID}\"\n  auth:\n    users:\n      - user_id: 123456789\n        roles: [read_status, execute_action, admin]\n  rate_limits:\n    view: 10\n    control: 5\n    dangerous: 2"
        }
      },
      "testing": {
        "mock_notifier": {
          "class": "TelegramNotifierMock",
          "location": "src/predarb/testing/",
          "purpose": "In-memory message storage (no HTTP calls)",
          "usage": "Engine(..., notifier=TelegramNotifierMock())",
          "benefits": [
            "No Telegram API credentials needed",
            "Deterministic (no network)",
            "Fast (no API latency)",
            "Inspectable (get_messages(), has_message_containing())"
          ]
        },
        "test_outbound": "pytest tests/test_simulation_harness.py::TestTelegramNotifierMock -v",
        "test_inbound": "pytest tests/test_telegram_interface.py -v",
        "full_integration": "pytest tests/test_simulation_harness.py::TestSimulationIntegration -v"
      }
    },
    "workflow_examples": {
      "example_1_quick_test": {
        "goal": "Quick test without hitting live API",
        "steps": [
          "python -m predarb selftest",
          "Runs against fixtures, exits in <5 seconds",
          "Output: validation results, no Telegram/API calls"
        ]
      },
      "example_2_single_iteration": {
        "goal": "Run one full iteration (detect & trade)",
        "setup": [
          "Set POLYMARKET_API_KEY, SECRET, PASSPHRASE env vars",
          "Configure config.yml (risk, filters, detectors)",
          "Optional: set TELEGRAM_ENABLED=true for notifications"
        ],
        "run": "python -m predarb once",
        "output": [
          "Fetches active markets from Polymarket API",
          "Runs detectors",
          "Executes trades (paper broker simulates)",
          "Logs results + sends Telegram notification",
          "Writes to reports/paper_trades.csv"
        ]
      },
      "example_3_continuous_run": {
        "goal": "Run bot indefinitely (production mode)",
        "setup": "Same as example_2",
        "run": "python -m predarb run",
        "output": [
          "Continuous loop: fetch markets ‚Üí detect ‚Üí trade ‚Üí sleep ‚Üí repeat",
          "Sleep duration: config.engine.refresh_seconds (default: 60)",
          "All trades logged to CSV",
          "All opportunities sent to Telegram (if enabled)",
          "Monitor via /status command (if Telegram configured)"
        ]
      },
      "example_4_simulation": {
        "goal": "Test against fake market data with real Telegram notifications",
        "setup": [
          "Optional: Set TELEGRAM env vars for real notifications",
          "No Polymarket credentials needed (uses FakePolymarketClient)"
        ],
        "run": "python sim_run.py --days 5 --trade-size 200",
        "output": [
          "Generates 50 synthetic markets (or --markets N)",
          "Simulates 5 days of market evolution",
          "Runs engine repeatedly (detects & executes trades)",
          "Sends real Telegram notifications (or --no-telegram for mock)",
          "Final report: P&L, Sharpe ratio, max drawdown, trade count"
        ]
      },
      "example_5_telegram_control": {
        "goal": "Monitor and control bot via Telegram",
        "prerequisites": [
          "Bot running (python -m predarb run &)",
          "Telegram configured and enabled",
          "TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID set"
        ],
        "commands": [
          "User: /status",
          "Bot: ü§ñ Bot Status\nState: RUNNING\nMode: PAPER\nBalance: $10000\nPositions: 3\nP&L: $245.67",
          "",
          "User: /daily",
          "Bot: üìà Daily Summary\nTotal P&L: $245.67\nRealized: $120.00\nUnrealized: $125.67\nReturn: 2.46%",
          "",
          "User: /freeze all (requires execute_action role)",
          "Bot: üîí Frozen: all\n(bot stops entering new trades)",
          "",
          "User: /mode live (requires 2-step confirmation)",
          "Bot: üîê Confirm with /confirm ABC123\n(user replies /confirm ABC123)",
          "Bot: ‚úÖ Confirmed. Mode changed to LIVE"
        ]
      }
    },
    "configuration_reference": {
      "file": "config.yml",
      "sections": {
        "polymarket": [
          "host: API endpoint (default: https://clob.polymarket.com)",
          "api_key: CLOB API key",
          "secret: CLOB secret",
          "passphrase: CLOB passphrase",
          "private_key: Ethereum private key (for signing)",
          "chain_id: Network (default: 137 = Polygon mainnet)",
          "funder: Funder wallet address"
        ],
        "broker": [
          "initial_cash: Starting capital for paper trading ($10000 default)",
          "fee_bps: Fee in basis points (10 = 0.1%, default: 10)",
          "slippage_bps: Slippage modeling (20 = 0.2%, default: 20)",
          "depth_fraction: Liquidity fraction available (0.05 = 5% depth, default: 0.05)"
        ],
        "risk": [
          "max_allocation_per_market: Max % of capital per position (default: 5%)",
          "max_open_positions: Max concurrent open positions (default: 10)",
          "min_liquidity_usd: Minimum market liquidity to trade ($100 default)",
          "min_net_edge_threshold: Minimum profitability threshold (0.01 = 1%, default: 0.01)",
          "kill_switch_drawdown: Max portfolio drawdown before halt (0.5 = 50%, default: 0.5)"
        ],
        "engine": [
          "refresh_seconds: Sleep between iterations (60 default)",
          "iterations: Max number of runs (-1 = infinite, default: -1)",
          "report_path: CSV output path (default: reports/paper_trades.csv)"
        ],
        "filter": [
          "max_spread_pct: Max price spread % (0.1 = 10%, default: 0.1)",
          "min_volume_24h: Min trading volume ($1000 default)",
          "min_liquidity: Min market liquidity USD ($500 default)",
          "min_days_to_expiry: Min days until market closes (1 default)",
          "require_resolution_source: Must have resolution source (true default)",
          "min_rank_score: Min composite market score (0.5 default)",
          "spread_score_weight: Weight in ranking (0.3 default)",
          "volume_score_weight: Weight in ranking (0.35 default)",
          "liquidity_score_weight: Weight in ranking (0.35 default)"
        ],
        "detectors": [
          "parity_threshold: Min outcomes sum (0.99 default)",
          "duplicate_price_diff_threshold: Max price diff between clones (0.05 = 5%, default: 0.05)",
          "exclusive_sum_tolerance: Tolerance for exclusive sum check (0.01 default)",
          "ladder_tolerance: Tolerance for ladder detection (0.02 default)",
          "timelag_price_jump: Min price jump for timelag (0.05 default)",
          "timelag_persistence_minutes: How long timelag persists (10 default)"
        ],
        "telegram": [
          "enabled: Enable notifications (false default)",
          "bot_token: Telegram bot token (from @BotFather)",
          "chat_id: Telegram chat ID (your personal chat ID)",
          "auth: User roles and permissions",
          "rate_limits: Commands per minute by risk level"
        ]
      }
    },
    "module_map": {
      "core_engine": {
        "file": "src/predarb/engine.py",
        "class": "Engine",
        "entry": "run() or run_once()",
        "orchestrates": [
          "PolymarketClient.get_active_markets()",
          "FilterMarkets.filter_markets()",
          "Detector pipeline (6 detectors)",
          "RiskManager.check_limits()",
          "PaperBroker.execute(opportunity)",
          "Notifier.send_message()"
        ]
      },
      "detectors": {
        "location": "src/predarb/detectors/",
        "pattern": "class XyzDetector: def detect(markets) ‚Üí List[Opportunity]",
        "detectors": [
          "ParityDetector - outcomes don't sum to 1",
          "LadderDetector - sequential outcome prices",
          "DuplicateDetector - clone markets, price divergence",
          "ExclusiveSumDetector - mutually exclusive check",
          "TimeLagDetector - stale prices",
          "ConsistencyDetector - cross-market validation"
        ]
      },
      "config": {
        "location": "src/predarb/config.py",
        "classes": [
          "AppConfig - root config",
          "PolymarketConfig - API settings",
          "BrokerConfig - trading params",
          "RiskConfig - risk limits",
          "FilterConfig - market filtering",
          "DetectorConfig - detector thresholds",
          "TelegramConfig - notifications",
          "EngineConfig - engine loop"
        ]
      },
      "models": {
        "location": "src/predarb/models.py",
        "classes": [
          "Market - pydantic model for market data",
          "Outcome - pydantic model for outcomes",
          "Opportunity - dataclass for detected arb",
          "Trade - dataclass for executed trade",
          "TradeAction - dataclass for single trade component"
        ]
      },
      "broker": {
        "location": "src/predarb/broker.py",
        "class": "PaperBroker",
        "simulates": "Trade execution (fees, slippage, liquidity constraints)",
        "tracks": "Positions, P&L, equity, cash balance"
      },
      "notifier": {
        "location": "src/predarb/notifiers/",
        "base": "Notifier (abstract)",
        "implementations": [
          "TelegramNotifierReal - sends to Telegram API",
          "TelegramNotifierMock - in-memory (testing)"
        ]
      },
      "telegram_bot": {
        "location": "arbitrage_bot/",
        "components": [
          "main.py - TelegramControlledArbitrageBot orchestrator",
          "core/bot_loop.py - async execution loop",
          "core/control_queue.py - command queue",
          "core/state.py - bot state snapshot",
          "core/actions.py - action dataclasses",
          "telegram/router.py - command parsing & routing",
          "telegram/handlers.py - command handlers",
          "telegram/security.py - auth, confirmation, formatting",
          "telegram/rate_limit.py - rate limiting"
        ]
      },
      "stress_testing": {
        "injection": {
          "location": "src/predarb/injection.py",
          "classes": [
            "MarketProvider (Protocol) - interface for real/injected clients",
            "InjectionSource - factory for creating providers from specs",
            "FileMarketProvider - load markets from JSON file",
            "InlineMarketProvider - parse markets from inline JSON string"
          ],
          "purpose": "Enable network-free testing with deterministic market data"
        },
        "scenarios": {
          "location": "src/predarb/stress_scenarios.py",
          "classes": [
            "StressScenario (base class) - seeded scenario generation",
            "HighVolumeScenario - 1000 markets (performance test)",
            "ManyRiskRejectionsScenario - 40 markets (risk validation test)",
            "PartialFillScenario - 10 markets (hedge logic test)",
            "HappyPathScenario - 15 markets (success case test)",
            "LatencyFreshnessScenario - 15 markets (expiry validation test)",
            "FeeSlippageScenario - 20 markets (cost modeling test)",
            "SemanticClusteringScenario - 25 markets (semantic clustering + filter test)"
          ],
          "functions": [
            "get_scenario(name, seed) - get scenario by name",
            "list_scenarios() - list available scenario names"
          ],
          "purpose": "Built-in stress test scenarios for comprehensive pipeline testing"
        },
        "verification": {
          "location": "src/predarb/verify_reports.py",
          "classes": [
            "ReportVerifier - verify unified_report.json structure and invariants"
          ],
          "functions": [
            "verify_reports(report_path, verbose) - verify and return exit code",
            "main() - CLI entry point"
          ],
          "exit_codes": {
            "EXIT_OK": 0,
            "EXIT_MISSING": 2,
            "EXIT_INVALID_SCHEMA": 3,
            "EXIT_NO_ITERATIONS": 4,
            "EXIT_MISSING_DATA": 5,
            "EXIT_INVARIANT_FAILED": 6
          },
          "purpose": "Validate reports and return meaningful exit codes for CI/CD"
        }
      }
    },
    "environment_variables": {
      "polymarket_credentials": [
        "POLYMARKET_API_KEY (required)",
        "POLYMARKET_SECRET (required)",
        "POLYMARKET_PASSPHRASE (required)",
        "POLYMARKET_PRIVATE_KEY (optional, for signing)",
        "POLYMARKET_FUNDER (optional, wallet address)"
      ],
      "telegram": [
        "TELEGRAM_ENABLED (true/false, default: false)",
        "TELEGRAM_BOT_TOKEN (required if enabled)",
        "TELEGRAM_CHAT_ID (required if enabled)"
      ],
      "setup": [
        "Create .env file in root directory",
        "Add KEY=VALUE pairs",
        "python-dotenv automatically loads"
      ],
      "example_env": "POLYMARKET_API_KEY=your_key\nPOLYMARKET_SECRET=your_secret\nPOLYMARKET_PASSPHRASE=your_pass\nTELEGRAM_ENABLED=true\nTELEGRAM_BOT_TOKEN=123:ABC...\nTELEGRAM_CHAT_ID=987654321"
    },
    "output_files": {
      "unified_report": {
        "path": "reports/unified_report.json",
        "purpose": "Single JSON file containing all reporting data (iterations + opportunity executions)",
        "format": "JSON with two top-level arrays",
        "structure": {
          "iterations": [
            {
              "iteration": "int - iteration number",
              "timestamp": "ISO 8601 timestamp",
              "markets_count": "int - total markets processed",
              "opportunities_detected": "int - opportunities found",
              "opportunities_approved": "int - opportunities passing risk checks",
              "approval_rate": "float - approved/detected ratio",
              "status": "str - iteration status (e.g., 'complete')"
            }
          ],
          "opportunity_executions": [
            {
              "opportunity_id": "str - unique opportunity identifier",
              "timestamp": "ISO 8601 timestamp",
              "iteration": "int - which iteration detected this",
              "detector": "str - detector name",
              "markets": "list of market identifiers",
              "actions": "list of trade actions executed",
              "status": "str - execution status",
              "pnl": "float - profit/loss if applicable"
            }
          ]
        },
        "write_safety": "Atomic write (temp file then rename) prevents corruption",
        "api": {
          "report_iteration(iteration, markets_count, opps_detected, opps_approved, status)": "Log iteration summary",
          "log_opportunity_execution(opp_id, detector, markets, actions, status, pnl)": "Log opportunity execution",
          "log_trades(trades_list)": "Log multiple trades at once"
        },
        "migration_from_legacy": "Replaces live_summary.csv + opportunity_logs.jsonl with single JSON file",
        "backward_compatibility": "Use export_legacy_csv() to generate old CSV files from unified JSON"
      },
      "legacy_csv_trades": {
        "path": "reports/paper_trades.csv",
        "purpose": "Legacy CSV log of executed trades (can be exported from unified_report.json)",
        "status": "DEPRECATED - Use unified_report.json instead",
        "columns": [
          "timestamp",
          "market_id",
          "outcome_id",
          "side",
          "amount",
          "price",
          "fees",
          "slippage",
          "realized_pnl"
        ],
        "export_function": "export_legacy_csv() in unified_reporter.py"
      },
      "legacy_live_reporting": {
        "path": "reports/live_summary.csv",
        "purpose": "Legacy CSV summary (can be exported from unified_report.json)",
        "status": "DEPRECATED - Use unified_report.json instead",
        "columns": [
          "TIMESTAMP","READABLE_TIME","ITERATION","MARKETS","MARKETS_Œî","DETECTED","DETECTED_Œî","APPROVED","APPROVED_Œî","APPROVAL%","STATUS","MARKET_HASH","OPP_HASH"
        ],
        "export_function": "export_legacy_csv() in unified_reporter.py"
      },
      "reporter_junit": {
        "path": "reports/reporter-tests.xml",
        "purpose": "JUnit XML from reporter tests (for CI visibility)"
      },
      "logs": {
        "destination": "stdout",
        "format": "[timestamp] [level] [module]: [message]",
        "level": "DEBUG, INFO, WARNING, ERROR"
      },
      "telegram_messages": {
        "destination": "Telegram chat (if enabled)",
        "types": "trade_entered, trade_exited, daily_summary, status_reply, error_alert, risk_warning"
      }
    },
    "dependencies": {
      "core": [
        "requests - HTTP client",
        "pydantic - data validation",
        "pyyaml - YAML parsing",
        "python-dotenv - env loading"
      ],
      "trading": [
        "py-clob-client - Polymarket API",
        "eth-account - Ethereum signing",
        "python-dateutil - date parsing"
      ],
      "notifications": [
        "python-telegram-bot - Telegram integration"
      ],
      "testing": [
        "pytest - test framework",
        "pytest-asyncio - async test support"
      ]
    },
    "quick_reference": {
      "start_quick_test": "python -m predarb selftest",
      "start_once": "python -m predarb once (requires API creds)",
      "start_production": "python -m predarb run (infinite loop)",
      "start_simulation": "python sim_run.py --days 5",
      "start_stress_test": "python -m predarb stress --scenario happy_path",
      "start_stress_heavy": "python -m predarb stress --scenario high_volume --iterations 10",
      "start_stress_semantic": "python -m predarb stress --scenario semantic_clustering",
      "verify_reports": "python -m predarb.verify_reports",
      "run_tests": "pytest tests/ (34/36 tests passing as of 2026-01-07)",
      "run_stress_tests": "pytest tests/test_injection.py tests/test_stress_scenarios.py tests/test_verify_reports.py -v",
      "enable_telegram": "Set TELEGRAM_ENABLED=true, bot_token, chat_id",
      "view_unified_report": "cat reports/unified_report.json | python -m json.tool",
      "export_legacy_csv": "python -c 'from src.predarb.unified_reporter import export_legacy_csv; export_legacy_csv()'",
      "read_report_summary": "python -c 'from src.predarb.unified_reporter import read_unified_report; print(read_unified_report())'",
      "check_api": "python check_connection.py",
      "telegram_commands": "/start /pause /stop /status /daily /mode /freeze /unfreeze /forceclose /help",
      "rate_limits": "VIEW: 10/min, CONTROL: 5/min, DANGEROUS: 2/min",
      "confirmation": "Dangerous commands need 2-step: command ‚Üí code ‚Üí /confirm code",
      "test_status": "34/36 tests passing (94% success rate)",
      "stress_scenarios": "high_volume, many_risk_rejections, partial_fill, happy_path, latency_freshness, fee_slippage"
    }
  }
}
