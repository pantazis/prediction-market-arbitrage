{
  "codebase_operations": {
    "version": "2.7",
    "generated": "2026-01-09",
    "project": "prediction-market-arbitrage",
    "description": "Complete operational reference for running, testing, simulating, and controlling the arbitrage bot",
    "section": "ALL_OPERATIONS",
    "live_paper_trading": {
      "status": "PRODUCTION_READY",
      "version": "1.0",
      "added": "2026-01-09",
      "description": "Live paper-trading arbitrage runner using ONLY real-time market data with full PnL tracking and rebalancing",
      "purpose": "Run the bot TODAY with real-time API data, paper trades (no real orders), and comprehensive reporting",
      "architecture": {
        "components": [
          "LivePaperTradingRunner - Main execution controller with wallet tracking",
          "PaperBroker - Simulates order execution with fees/slippage",
          "Engine - Core arbitrage detection engine",
          "UnifiedReporter - Comprehensive reporting system"
        ],
        "data_sources": [
          "Real-time Polymarket API (gamma-api.polymarket.com)",
          "Real-time Kalshi API (optional, if credentials provided)",
          "Order book depth data for execution simulation",
          "NO historical data, NO injected data, NO backfill"
        ]
      },
      "paper_wallet_tracking": {
        "available_usdc": "Cash available for new trades",
        "reserved_usdc": "Cash locked in pending orders",
        "realized_pnl_usdc": "Closed position profits/losses",
        "unrealized_pnl_usdc": "Open position mark-to-market PnL",
        "fees_paid_usdc": "Total taker fees incurred",
        "slippage_cost_usdc": "Total slippage costs",
        "positions": "Inventory per venue/market/outcome (Dict[str, float])"
      },
      "bot_loop": {
        "frequency": "Every 5 seconds (configurable)",
        "steps": [
          "1. Check wallet balances",
          "2. Fetch real-time prices from API",
          "3. Fetch real-time order books (depth)",
          "4. Calculate spreads and edges",
          "5. Validate fees, slippage, depth, risk limits",
          "6. Detect arbitrage opportunities",
          "7. Calculate position sizes based on wallet",
          "8. Construct both legs of trade",
          "9. Paper-place orders (simulate execution)",
          "10. Monitor fills (based on book depth)",
          "11. Handle partial fills (hedge or cancel)",
          "12. Confirm executions",
          "13. Update wallet and inventory",
          "14. Record realized PnL",
          "15. Rebalance inventory if needed",
          "16. Log everything",
          "17. Sleep until next iteration"
        ]
      },
      "stop_conditions": {
        "duration_limit": "Default 8 hours (--duration flag overrides)",
        "drawdown_limit": "15% loss triggers emergency stop",
        "manual_interrupt": "Ctrl+C for graceful shutdown"
      },
      "commands": {
        "automated_setup": {
          "command": "./run_live_paper_setup.sh",
          "description": "One-command setup: installs deps, validates config, tests API, runs bot",
          "options": [
            "--duration HOURS - Run duration (default 8.0)",
            "--capital USDC - Starting capital (default 500.0)",
            "--log-level LEVEL - DEBUG|INFO|WARNING|ERROR"
          ]
        },
        "direct_execution": {
          "command": "python3 run_live_paper.py",
          "description": "Run live paper trading with real-time data",
          "options": [
            "--duration HOURS - How long to run (default 8.0)",
            "--capital USDC - Starting balance (default 500.0)",
            "--config PATH - Config file (default config_live_paper.yml)",
            "--log-level LEVEL - Logging verbosity"
          ],
          "examples": [
            "python3 run_live_paper.py --duration 0.1  # Quick 6-minute test",
            "python3 run_live_paper.py --duration 4 --capital 1000  # 4 hours, 1000 USDC",
            "python3 run_live_paper.py --log-level DEBUG  # Debug mode"
          ]
        },
        "validation": {
          "command": "python3 validate_live_paper_setup.py",
          "description": "Pre-flight validation: checks Python, deps, config, API, files",
          "exit_codes": {
            "0": "All checks passed, ready to run",
            "1": "One or more checks failed"
          }
        }
      },
      "outputs": {
        "live_console": "Real-time wallet state, opportunities, trades (every 10 iterations)",
        "end_report": "Comprehensive summary: PnL, trades, opportunities, positions",
        "files": [
          "reports/live_paper_trades.csv - Complete trade log",
          "reports/unified_report.json - Full session metrics",
          "reports/live_summary.csv - Iteration summaries"
        ]
      },
      "safety_features": {
        "kill_switch": "Auto-stop at 15% drawdown",
        "position_limits": "Max 5 concurrent positions",
        "size_limits": "Max 10% capital per trade",
        "liquidity_checks": "Requires 5x depth for order size",
        "time_filters": "Rejects markets expiring within 48 hours",
        "spread_limits": "Rejects markets with >8% spread",
        "no_short_selling": "Hard-blocked at broker level",
        "data_validation": "Verifies no injection/fake clients on startup"
      },
      "invariants": [
        "Balances never negative (enforced at broker)",
        "No short selling (SELL only if position exists)",
        "Reserved funds properly tracked and released",
        "PnL reconciliation (realized + unrealized = total)",
        "Position tracking accurate across all venues"
      ],
      "files": {
        "config_live_paper.yml": "Configuration for live paper trading (500 USDC, 8h, conservative risk)",
        "run_live_paper.py": "Main runner (481 lines) - LivePaperTradingRunner class",
        "run_live_paper_setup.sh": "Automated setup script (215 lines)",
        "validate_live_paper_setup.py": "Pre-flight validation (160 lines)",
        "LIVE_PAPER_TRADING_GUIDE.md": "Complete user guide (520+ lines)",
        "LIVE_PAPER_TRADING_COMMANDS.md": "Command reference (350+ lines)",
        "README_LIVE_PAPER_TRADING.md": "Executive summary (520+ lines)",
        "QUICKSTART_LIVE_PAPER.md": "Quick reference card"
      }
    },
    "dual_venue_stress_testing": {
      "status": "PRODUCTION_READY",
      "version": "1.0",
      "added": "2026-01-09",
      "description": "Comprehensive end-to-end stress testing framework for dual-venue arbitrage detection with deterministic fake data injection",
      "architecture": {
        "components": [
          "DualInjectionClient - merges markets from two independent providers",
          "InjectionFactory - creates providers from injection specs",
          "CrossVenueArbitrageScenarios - generates comprehensive test markets",
          "ScenarioValidator - validates expected results"
        ],
        "injection_specs": [
          "scenario:<name> - built-in stress scenarios",
          "file:<path> - load from JSON fixture",
          "inline:<json> - parse inline JSON",
          "none - disable venue"
        ]
      },
      "arbitrage_types_covered": {
        "duplicate": "Cross-venue price differences (same event, different prices)",
        "parity": "YES+NO != 1.0 within single venue",
        "ladder": "Price monotonicity violations across thresholds",
        "exclusive_sum": "Mutually exclusive outcomes sum > 1.0",
        "timelag": "Stale quote arbitrage (delayed price updates)",
        "consistency": "Cross-market logical contradictions",
        "composite": "Hierarchical event mispricing (P(composite) > P(component))"
      },
      "scenario_cases": {
        "positive_cases": "Profitable opportunities that should be detected",
        "negative_cases": "Opportunities that should be rejected (low liquidity, tiny edge, etc.)",
        "edge_cases": "Partial fills, fee mismatches, tick rounding, date mismatches"
      },
      "commands": {
        "run_all_scenarios": {
          "command": "python run_all_scenarios.py",
          "description": "Run comprehensive test suite with validation",
          "options": [
            "--seed N - set random seed (default 42)",
            "--quiet - reduce output verbosity"
          ],
          "exit_codes": {
            "0": "All tests passed",
            "1": "At least one test failed"
          }
        },
        "cli_dual_stress": {
          "command": "python -m predarb dual-stress",
          "description": "Run dual-venue stress test via CLI",
          "required_args": "--cross-venue OR (--inject-a AND/OR --inject-b)",
          "examples": [
            "python -m predarb dual-stress --cross-venue",
            "python -m predarb dual-stress --inject-a scenario:happy_path --inject-b scenario:high_volume",
            "python -m predarb dual-stress --inject-a file:poly.json --inject-b file:kalshi.json",
            "python -m predarb dual-stress --inject-a scenario:parity_arb --inject-b none"
          ]
        },
        "single_venue_stress": {
          "command": "python -m predarb stress",
          "description": "Original single-venue stress test (still supported)",
          "examples": [
            "python -m predarb stress --scenario happy_path",
            "python -m predarb stress --inject file:markets.json"
          ]
        }
      },
      "validation": {
        "market_validation": [
          "Market counts add up correctly",
          "All markets have exchange tags",
          "All outcome IDs unique within markets",
          "All dates valid",
          "All prices in [0, 1] range"
        ],
        "opportunity_validation": [
          "Expected opportunity types detected",
          "Minimum detection counts met",
          "Some opportunities approved",
          "Approval rate reasonable"
        ],
        "determinism_validation": [
          "Same seed produces identical market counts",
          "Same seed produces identical market IDs",
          "Same seed produces identical prices"
        ],
        "report_validation": [
          "Unified report exists",
          "Report contains expected structure"
        ]
      },
      "files": {
        "src/predarb/dual_injection.py": "Dual-venue injection mechanism (DualInjectionClient, InjectionFactory)",
        "src/predarb/cross_venue_scenarios.py": "Comprehensive scenario generator (CrossVenueArbitrageScenarios)",
        "src/predarb/cli.py": "CLI with dual-stress command",
        "run_all_scenarios.py": "Master test runner with validation",
        "tests/test_dual_injection.py": "Unit tests for injection (24 tests)",
        "tests/test_cross_venue_scenarios.py": "Unit tests for scenarios (23 tests)",
        "DUAL_VENUE_STRESS_TESTING.md": "Comprehensive documentation"
      },
      "integration": {
        "engine_compatible": true,
        "detector_compatible": true,
        "risk_manager_compatible": true,
        "reporter_compatible": true,
        "backward_compatible": true,
        "network_calls": false,
        "deterministic": true
      },
      "testing": {
        "unit_tests": "pytest tests/test_dual_injection.py tests/test_cross_venue_scenarios.py -v",
        "integration_test": "python run_all_scenarios.py",
        "total_tests": 47,
        "coverage": ["injection", "scenarios", "validation", "determinism", "CLI"]
      }
    },
    "strict_ab_validation": {
      "status": "PRODUCTION_READY",
      "version": "1.0",
      "added": "2026-01-09",
      "description": "Comprehensive validation system proving STRICT A+B MODE operation - system ONLY detects arbitrage requiring BOTH venues",
      "validation_rules": {
        "rule_1": "Exactly 2 venues per opportunity (one A, one B)",
        "rule_2": "At least one leg on venue A (Kalshi-like, supports shorting)",
        "rule_3": "At least one leg on venue B (Polymarket-like, NO shorting)",
        "rule_4": "No SELL-TO-OPEN on venue B (inventory required)",
        "rule_5": "Opportunity requires BOTH venues (not executable on one alone)"
      },
      "venue_definitions": {
        "venue_a_kalshi": {
          "name": "kalshi",
          "supports_shorting": true,
          "allowed_actions": ["BUY", "SELL-TO-OPEN", "SELL-TO-CLOSE"]
        },
        "venue_b_polymarket": {
          "name": "polymarket",
          "supports_shorting": false,
          "allowed_actions": ["BUY", "SELL-TO-CLOSE"],
          "forbidden_actions": ["SELL-TO-OPEN", "SHORT"]
        }
      },
      "commands": {
        "cli_validation": {
          "command": "python -m predarb validate-ab",
          "options": [
            "--config CONFIG_PATH (default: config_strict_ab.yml)",
            "--seed SEED (default: 42)"
          ],
          "description": "Run strict A+B validation via CLI with full engine integration"
        },
        "simple_test": {
          "command": "python test_strict_ab_validator.py",
          "description": "Standalone test without engine - validates core logic only",
          "exit_code": "0 if all tests pass, 1 if failures"
        },
        "comprehensive_validation": {
          "command": "python validate_strict_ab_mode.py",
          "description": "Full 8-test validation suite (requires all dependencies)",
          "tests": [
            "Load configuration",
            "Generate test scenarios (valid + invalid cases)",
            "Setup dual-venue injection",
            "Run engine and detect opportunities",
            "Validate venue tagging",
            "Run strict A+B validation",
            "Verify zero false positives",
            "Generate validation report"
          ]
        }
      },
      "test_scenarios": {
        "valid_ab_scenarios": [
          "Cross-venue parity (same event, mispriced across venues)",
          "Cross-venue complement (YES on A + NO on B < 1.0)",
          "Cross-venue ladder (threshold markets with monotonicity violation)",
          "Cross-venue with Kalshi short leg (requires venue A shorting)"
        ],
        "invalid_scenarios_should_reject": [
          "Single-venue parity (Polymarket only)",
          "Single-venue parity (Kalshi only)",
          "Polymarket-only arbitrage (no Kalshi market)",
          "Arbitrage requiring Polymarket shorting (FORBIDDEN)",
          "Theoretical arithmetic arbitrage (no venue constraint)",
          "Edge-positive but insufficient liquidity"
        ],
        "total_scenarios": 10,
        "expected_valid": 4,
        "expected_rejected": 6
      },
      "modules": {
        "validator": {
          "file": "src/predarb/strict_ab_validator.py",
          "classes": [
            "VenueConstraints - Defines allowed actions per venue",
            "ValidationResult - Result with rejection details",
            "StrictABValidator - Main validator with venue enforcement"
          ],
          "key_methods": [
            "validate_opportunity(opp, market_lookup) → ValidationResult",
            "validate_batch(opportunities, market_lookup) → (valid, rejected)",
            "generate_validation_report(opportunities, market_lookup) → Dict"
          ]
        },
        "scenarios": {
          "file": "src/predarb/strict_ab_scenarios.py",
          "classes": [
            "ScenarioMetadata - Test scenario expectations",
            "StrictABScenarios - Comprehensive test generator"
          ],
          "function": "get_strict_ab_scenario(seed) → (poly_markets, kalshi_markets, metadata)"
        },
        "test_runners": {
          "simple": "test_strict_ab_validator.py (standalone, no dependencies)",
          "comprehensive": "validate_strict_ab_mode.py (full engine integration)"
        }
      },
      "validation_output": {
        "console": {
          "total_opportunities_detected": "Count from all detectors",
          "total_valid": "Opportunities passing A+B constraints",
          "total_rejected": "Opportunities failing constraints",
          "rejection_rate": "Percentage rejected",
          "rejections_by_reason": {
            "insufficient_venues": "Single-venue arbitrage detected",
            "forbidden_action": "Polymarket shorting attempt",
            "forbidden_opportunity_type": "Type not allowed in A+B mode"
          },
          "valid_by_type": "Breakdown by arbitrage type (PARITY, LADDER, etc.)"
        },
        "json_report": {
          "path": "reports/strict_ab_validation_report.json",
          "structure": {
            "timestamp": "ISO8601 UTC",
            "seed": "Random seed used",
            "config": "Config file path",
            "validation_mode": "STRICT_A+B",
            "summary": "Market/scenario/detection/validation counts",
            "validation_results": "Detailed breakdown",
            "scenarios": "Expected vs actual for each scenario",
            "test_results": "Pass/fail/warn for each test"
          }
        }
      },
      "success_criteria": {
        "zero_false_positives": "No forbidden arbitrage approved",
        "single_venue_rejected": "All single-venue opportunities rejected",
        "polymarket_short_rejected": "All Polymarket shorting attempts rejected",
        "cross_venue_approved": "Valid A+B opportunities approved",
        "deterministic": "Same seed → same results"
      },
      "configuration": {
        "config_file": "config_strict_ab.yml",
        "settings": {
          "detectors": ["parity", "ladder", "exclusive_sum", "consistency", "composite"],
          "duplicate_disabled": "Explicitly disabled (requires short selling)",
          "min_gross_edge": "5% (strict threshold)",
          "min_liquidity": "5000 USD",
          "min_expiry_hours": "48 hours",
          "fee_bps": "20 (0.2%)",
          "slippage_bps": "30 (0.3%)"
        }
      },
      "integration": {
        "with_engine": "Wraps Engine output to filter opportunities post-detection",
        "with_risk_manager": "Complements RiskManager's BUY-only enforcement",
        "with_dual_injection": "Uses DualInjectionClient for test data",
        "with_cli": "Integrated as 'validate-ab' command in predarb CLI"
      },
      "files": {
        "src/predarb/strict_ab_validator.py": "Validator logic (380 lines)",
        "src/predarb/strict_ab_scenarios.py": "Test scenario generator (700+ lines)",
        "test_strict_ab_validator.py": "Simple standalone test (200 lines)",
        "validate_strict_ab_mode.py": "Comprehensive validation runner (450 lines)",
        "config_strict_ab.yml": "Strict mode configuration"
      },
      "example_output": {
        "console": "================================================================================\nSTRICT A+B MODE VALIDATION\n✓ Generated 19 Polymarket + 14 Kalshi markets\n✓ Generated 18 test scenarios\n✓ Total detected: 13 opportunities\n✓ Valid A+B: 4, Rejected: 9 (69.2%)\n  Rejections: insufficient_venues=9\n  Valid types: LADDER=1, COMPOSITE=3\n✅ VALIDATION PASSED\n================================================================================" ,
        "json_fields": "timestamp, seed, config, validation_mode, summary, validation_results, scenarios, test_results"
      },
      "test_scenarios_expanded": {
        "description": "18 comprehensive scenarios covering all 7 arbitrage types with valid and invalid variants",
        "valid_ab_scenarios_8": {
          "1_cross_venue_parity": "Same event priced differently on Poly vs Kalshi",
          "2_cross_venue_complement": "YES on Kalshi + NO on Polymarket < 1.0",
          "3_cross_venue_ladder": "Threshold markets with monotonicity violation across venues",
          "4_cross_venue_with_short": "Requires Kalshi short leg (venue A supports shorting)",
          "5_range_replication_valid": "Replicate range using Kalshi short + Polymarket long",
          "6_multi_outcome_additivity": "Cross-venue outcome sum arbitrage",
          "7_composite_hierarchical": "P(championship) > P(semifinal) across venues",
          "8_calendar_basis_valid": "Time spread arbitrage across venues"
        },
        "invalid_scenarios_10": {
          "9_single_venue_parity_poly": "Parity violation on Polymarket only",
          "10_single_venue_parity_kalshi": "Parity violation on Kalshi only",
          "11_polymarket_only": "Arbitrage with no Kalshi market",
          "12_polymarket_short_forbidden": "Would require Polymarket shorting (FORBIDDEN)",
          "13_theoretical_arithmetic": "Arithmetic arbitrage without venue distinction",
          "14_tiny_liquidity": "Edge positive but execution invalid",
          "15_range_replication_single": "Range replication on Polymarket only",
          "16_multi_outcome_requires_short": "Multi-outcome requiring Polymarket short",
          "17_composite_single_venue": "Composite arbitrage within one venue",
          "18_calendar_basis_insufficient": "Calendar spread with insufficient time delta"
        },
        "arbitrage_types_covered": [
          "PARITY (outcomes don't sum to 1.0)",
          "LADDER (threshold monotonicity violations)",
          "DUPLICATE (cross-venue price differences)",
          "EXCLUSIVE_SUM (mutually exclusive sum > 1.0)",
          "COMPOSITE (hierarchical event mispricing)",
          "RANGE_REPLICATION (synthetic range via options)",
          "CALENDAR_BASIS (time spread arbitrage)"
        ]
      },
      "detector_integration": {
        "composite_detector_added": "2026-01-09",
        "description": "CompositeDetector now enabled by default in strict A+B config",
        "detection_improvement": "Increased valid detections from 4 to 7+ with semantic pattern matching",
        "patterns_detected": [
          "championship → final → semifinal → quarterfinal",
          "president → primary → caucus",
          "national → regional → local",
          "year → quarter → month → week"
        ],
        "violation_logic": "If P(broader_event) > P(narrower_event) + tolerance, flag arbitrage"
      }
    },
    "kalshi_integration": {
      "status": "PRODUCTION_READY",
      "version": "1.0",
      "added": "2026-01-09",
      "description": "Multi-exchange support with Kalshi as second market source alongside Polymarket",
      "architecture": {
        "interface": "MarketClient (abstract base class)",
        "implementations": ["PolymarketClient", "KalshiClient"],
        "authentication": "RSA-SHA256 request signing for Kalshi",
        "security": "NO hardcoded credentials - all from environment variables"
      },
      "configuration": {
        "file": "config.yml",
        "section": "kalshi",
        "required_env_vars": [
          "KALSHI_API_KEY_ID (UUID format)",
          "KALSHI_PRIVATE_KEY_PEM (RSA private key in PEM format)",
          "KALSHI_API_HOST (optional, defaults to https://trading-api.kalshi.com)",
          "KALSHI_ENV (optional, prod or demo, defaults to prod)"
        ],
        "enable_disable": "Set kalshi.enabled: true/false in config.yml",
        "filters": {
          "min_liquidity_usd": "Minimum market liquidity filter (default 500.0)",
          "min_days_to_expiry": "Minimum days until expiry (default 1)"
        }
      },
      "market_normalization": {
        "market_id_format": "kalshi:<event_ticker>:<market_ticker>",
        "outcomes": "Always YES/NO with prices normalized to [0.0-1.0]",
        "price_conversion": "Kalshi cents (0-100) divided by 100",
        "liquidity_estimation": "open_interest × yes_price",
        "exchange_tagging": "market.exchange = 'kalshi' or 'polymarket'"
      },
      "engine_behavior": {
        "client_loading": "Dynamic - loads all enabled clients from config",
        "market_fetching": "Sequential per exchange, then merged into single list",
        "detector_compatibility": "ALL detectors are exchange-agnostic",
        "risk_manager": "BUY-ONLY enforcement applies equally to all exchanges"
      },
      "testing": {
        "fake_client": "tests/fake_kalshi_client.py (NO network calls)",
        "test_suite": "tests/test_kalshi_integration.py (15 tests passing)",
        "fixtures": ["default (2 markets)", "high_volume (50 markets)", "parity_arb", "empty"],
        "coverage": ["normalization", "multi-exchange engine", "configuration", "security"]
      },
      "backward_compatibility": "FULLY COMPATIBLE - existing single-client code unchanged",
      "documentation": "KALSHI_INTEGRATION.md"
    },
    "bot_lifecycle": {
      "start_bot": {
        "description": "Start the arbitrage bot in background mode with proper environment setup",
        "commands": {
          "production_command": "cd /opt/prediction-market-arbitrage && PYTHONPATH=/opt/prediction-market-arbitrage/src .venv/bin/python -m predarb run --iterations 1000 > bot.log 2>&1 & echo $! > bot.pid",
          "explanation": "Starts bot with venv, PYTHONPATH set to src/, logs to bot.log, saves PID to bot.pid",
          "required_setup": [
            "Virtual environment must exist at .venv/",
            "PYTHONPATH must point to src/ directory for module imports",
            "Python module predarb must be importable from src/",
            "Run from /opt/prediction-market-arbitrage root directory"
          ]
        },
        "verification": {
          "check_pid": "cat bot.pid",
          "check_process": "ps -p $(cat bot.pid) -o pid,stat,cmd --no-headers",
          "check_logs": "tail -f bot.log",
          "check_recent_activity": "tail -50 bot.log"
        },
        "troubleshooting": {
          "module_not_found_predarb": {
            "error": "ModuleNotFoundError: No module named 'predarb'",
            "solution": "Set PYTHONPATH=/opt/prediction-market-arbitrage/src before running"
          },
          "recursion_error_unified_reporter": {
            "error": "RecursionError in _load_report()",
            "solution": "Fixed in unified_reporter.py - exception handler now returns fresh_structure instead of calling self recursively",
            "file": "src/predarb/unified_reporter.py lines 42-71"
          },
          "corrupted_report": {
            "error": "JSONDecodeError: Expecting value",
            "solution": "Remove corrupted report: rm -f /opt/prediction-market-arbitrage/reports/unified_report.json"
          },
          "python_command_not_found": {
            "error": "Command 'python' not found",
            "solution": "Use .venv/bin/python (full path to venv python) or python3"
          }
        },
        "dry_run_mode": {
          "description": "Bot runs in paper trading mode by default (no real money)",
          "config_location": "config.yml - broker section controls dry_run setting",
          "verification": "Check logs for 'Paper trading mode' or broker.initial_cash in config.yml"
        }
      },
      "stop_bot": {
        "description": "Stop a running bot process safely",
        "commands": {
          "using_pid_file": "kill $(cat bot.pid)",
          "force_kill": "kill -9 $(cat bot.pid)",
          "find_and_kill": "ps aux | grep '[p]ython.*predarb' | awk '{print $2}' | xargs kill"
        },
        "verification": {
          "check_stopped": "ps -p $(cat bot.pid) || echo 'Process stopped'",
          "check_no_orphans": "ps aux | grep '[p]ython.*predarb'"
        },
        "notes": [
          "Always stop old bot before starting new one to avoid conflicts",
          "PID file (bot.pid) tracks currently running bot",
          "Use regular kill first (allows graceful shutdown), only use kill -9 if process hangs"
        ]
      },
      "restart_bot": {
        "description": "Stop existing bot and start fresh instance",
        "commands": {
          "safe_restart": "kill $(cat bot.pid) 2>/dev/null; sleep 2; cd /opt/prediction-market-arbitrage && PYTHONPATH=/opt/prediction-market-arbitrage/src .venv/bin/python -m predarb run --iterations 1000 > bot.log 2>&1 & echo $! > bot.pid",
          "with_cleanup": "kill $(cat bot.pid) 2>/dev/null; rm -f reports/unified_report.json; cd /opt/prediction-market-arbitrage && PYTHONPATH=/opt/prediction-market-arbitrage/src .venv/bin/python -m predarb run --iterations 1000 > bot.log 2>&1 & echo $! > bot.pid"
        },
        "when_to_use": [
          "After fixing bugs in source code",
          "After updating configuration",
          "When bot process becomes unresponsive",
          "To start fresh with clean reports"
        ]
      },
      "monitor_bot": {
        "description": "Monitor running bot status and performance",
        "commands": {
          "live_logs": "tail -f bot.log",
          "recent_logs": "tail -50 bot.log",
          "process_status": "ps -p $(cat bot.pid) -o pid,stat,%cpu,%mem,etime,cmd",
          "report_status": "python check_continuous_run.py",
          "detailed_monitoring": "./monitor_bot.sh"
        },
        "key_indicators": {
          "markets_fetched": "INFO predarb.engine - Fetched N total markets",
          "markets_per_exchange": "INFO predarb.engine - Fetched N markets from polymarket/kalshi",
          "clients_active": "INFO predarb.engine - Engine initialized with clients: polymarket, kalshi",
          "opportunities_detected": "INFO predarb.unified_reporter - Iteration X: Recorded (markets=M, detected=D, approved=A)",
          "trades_executed": "INFO predarb.unified_reporter - Logged N trades to unified report",
          "errors": "ERROR or Traceback lines indicate issues",
          "kalshi_errors": "ERROR predarb.engine - Failed to fetch markets from kalshi"
        }
      },
      "enable_kalshi": {
        "description": "Enable Kalshi as second market source",
        "prerequisites": [
          "Kalshi API credentials (KALSHI_API_KEY_ID and KALSHI_PRIVATE_KEY_PEM)",
          "cryptography library installed (.venv/bin/pip install cryptography>=41.0.0)"
        ],
        "steps": [
          "1. Set environment variables: export KALSHI_API_KEY_ID='...' KALSHI_PRIVATE_KEY_PEM='...'",
          "2. Edit config.yml: Set kalshi.enabled: true",
          "3. Restart bot: kill $(cat bot.pid); PYTHONPATH=src .venv/bin/python -m predarb run --iterations 1000 > bot.log 2>&1 & echo $! > bot.pid"
        ],
        "verification": {
          "check_logs": "grep 'Engine initialized with clients' bot.log | tail -1",
          "expect": "Should see: polymarket, kalshi",
          "check_markets": "grep 'Fetched.*markets from kalshi' bot.log | tail -5"
        },
        "disable": "Set kalshi.enabled: false in config.yml and restart"
      }
    },
    "run_commands": {
      "main_cli": {
        "entry": "src/predarb/__main__.py",
        "class": "cli.main()",
        "commands": [
          {
            "cmd": "python -m predarb run",
            "mode": "run",
            "description": "Start infinite loop: detect arbs → execute trades → sleep → repeat",
            "config": "Reads config.yml (can override with --config PATH)",
            "iterations": "Infinite (--iterations N to set limit)",
            "env_requirements": ["POLYMARKET_API_KEY", "POLYMARKET_SECRET", "POLYMARKET_PASSPHRASE"],
            "output": "Logs to stdout + writes reports/paper_trades.csv + sends Telegram notifications (if enabled)",
            "when_to_use": "Production / continuous monitoring"
          },
          {
            "cmd": "python -m predarb once",
            "mode": "once",
            "description": "Run single iteration: detect arbs → execute trades → exit",
            "config": "Reads config.yml",
            "output": "Logs to stdout + writes to CSV + Telegram notification",
            "when_to_use": "Quick test, cron job, one-shot analysis"
          },
          {
            "cmd": "python demo_unified_reporting.py",
            "mode": "demo",
            "description": "Run UnifiedReporter demo to generate reports/unified_report.json without APIs",
            "output": "Creates reports/unified_report.json with iteration summary and opportunity logs",
            "when_to_use": "Sanity-check unified reporting locally"
          },
          {
            "cmd": "python -m predarb selftest",
            "mode": "selftest",
            "description": "Run against fixture data (no API calls, deterministic)",
            "config": "Uses test fixtures from tests/fixtures/markets.json",
            "env_requirements": "None (fixtures included)",
            "output": "Logs validation results, exits immediately",
            "when_to_use": "Verify code works without API, CI/CD pipeline"
          },
          {
            "cmd": "python -m predarb stress",
            "mode": "stress",
            "description": "DRY-RUN stress test with injectable market data (no network calls)",
            "injection_sources": [
              "scenario:<name> - built-in stress scenarios",
              "file:<path> - JSON fixture file",
              "inline:<json> - inline JSON payload"
            ],
            "arguments": [
              {
                "arg": "--scenario NAME",
                "description": "Use built-in stress scenario (shorthand for --inject scenario:NAME)",
                "examples": ["high_volume", "many_risk_rejections", "partial_fill", "happy_path", "latency_freshness", "fee_slippage", "semantic_clustering"]
              },
              {
                "arg": "--inject SPEC",
                "description": "Full injection spec: scenario:<name> | file:<path> | inline:<json>",
                "examples": [
                  "scenario:happy_path",
                  "file:tests/fixtures/markets.json",
                  "inline:[{\"id\":\"m1\",\"question\":\"Test?\",\"outcomes\":[...]}]"
                ]
              },
              {
                "arg": "--iterations N",
                "default": 1,
                "description": "Number of stress test iterations (default: 1)"
              },
              {
                "arg": "--seed N",
                "default": 42,
                "description": "Random seed for reproducible scenario generation"
              },
              {
                "arg": "--no-verify",
                "description": "Skip automatic report verification after stress test"
              },
              {
                "arg": "--config PATH",
                "description": "Custom config.yml (default: config.yml)"
              }
            ],
            "example_commands": [
              "python -m predarb stress --scenario happy_path (quick smoke test)",
              "python -m predarb stress --scenario high_volume --iterations 10 (stress with 1000 markets)",
              "python -m predarb stress --inject file:tests/fixtures/markets.json --seed 999",
              "python -m predarb stress --scenario partial_fill --no-verify (skip verification)"
            ],
            "exit_codes": {
              "0": "All checks passed (after auto-verification)",
              "1": "General error or user interrupt",
              "2": "Report file missing or unreadable",
              "3": "Report schema invalid (malformed JSON or missing keys)",
              "4": "No iterations recorded (unexpected empty report)",
              "5": "Expected executions/trades missing (data inconsistency)",
              "6": "Invariants failed (residual exposure not hedged, etc.)"
            },
            "stress_scenarios": {
              "high_volume": {
                "markets": 1000,
                "description": "990 normal markets + 10 arbitrage opportunities",
                "tests": "Performance and filtering efficiency"
              },
              "many_risk_rejections": {
                "markets": 40,
                "description": "20 low liquidity + 15 low edge + 5 good opportunities",
                "tests": "Risk manager validation and rejection handling"
              },
              "partial_fill": {
                "markets": 10,
                "description": "Asymmetric liquidity (deep YES, shallow NO)",
                "tests": "Hedge/cancel logic on execution failure"
              },
              "happy_path": {
                "markets": 15,
                "description": "Strong arbitrage opportunities with clean execution",
                "tests": "Success case end-to-end with realized P&L"
              },
              "latency_freshness": {
                "markets": 15,
                "description": "10 expiring soon + 5 fresh markets",
                "tests": "Expiry validation and freshness checks"
              },
              "fee_slippage": {
                "markets": 20,
                "description": "Marginal opportunities where fees/slippage eliminate edge",
                "tests": "Cost modeling and rejection"
              },
              "semantic_clustering": {
                "markets": 25,
                "description": "Markets with semantic duplicates (BTC/Bitcoin, Democrat variations) + filter violations (spread, volume, liquidity, expiry, resolution source) + distinct entities",
                "tests": "Semantic clustering with sentence-transformers, duplicate detection, all filter criteria (spread, volume, liquidity, expiry, resolution_source)"
              }
            },
            "flow": [
              "1. Parse injection spec (scenario/file/inline)",
              "2. Create injected market provider (seeded, deterministic)",
              "3. Replace Engine.client with injected provider",
              "4. Run stress test (run_once or run loop)",
              "5. Auto-verify reports/unified_report.json (unless --no-verify)",
              "6. Exit with verification exit code"
            ],
            "output": "reports/unified_report.json + stdout logs",
            "when_to_use": "CI/CD pipeline, pre-deployment validation, regression testing, stress testing filtering/risk/hedging logic",
            "env_requirements": "None (no network calls, uses injected data)"
          }
        ],
        "config_override": {
          "syntax": "python -m predarb [run|once|selftest|stress] --config /path/to/config.yml",
          "example": "python -m predarb stress --scenario happy_path --config my_config.yml"
        }
      },
      "continuous_mixed_mode": {
        "entry": "run_continuous_mixed.py",
        "cmd": "python run_continuous_mixed.py",
        "description": "Run bot continuously with MIXED real Polymarket + injected stress data for comprehensive testing and monitoring",
        "when_to_use": "Long-term testing (hours/days), stress testing with real API calls, production-like monitoring with controlled test scenarios",
        "features": [
          "Combines real Polymarket API data with injected stress scenarios",
          "Configurable mix ratio (default: 10% injected)",
          "Uses existing UnifiedReporter + LiveReporter systems",
          "Runs in background with nohup for multi-day testing",
          "Auto-generates iteration reports every cycle"
        ],
        "arguments": [
          {
            "arg": "--scenario NAME",
            "default": "high_volume",
            "choices": ["high_volume", "happy_path", "many_risk_rejections", "partial_fill", "latency_freshness", "fee_slippage", "semantic_clustering"],
            "description": "Stress scenario to inject alongside real data"
          },
          {
            "arg": "--days N",
            "default": 2.0,
            "description": "Number of days to run (can be fractional, e.g., 0.1 = 2.4 hours)"
          },
          {
            "arg": "--mix-ratio N",
            "default": 0.1,
            "description": "Ratio of injected to real markets (0.1 = 10% injected, 90% real)"
          },
          {
            "arg": "--config PATH",
            "default": "config.yml",
            "description": "Config file path"
          },
          {
            "arg": "--seed N",
            "default": 42,
            "description": "Random seed for reproducible injected scenarios"
          }
        ],
        "example_commands": [
          "python run_continuous_mixed.py --scenario high_volume --days 2 (2 days, 10% injected)",
          "python run_continuous_mixed.py --scenario happy_path --days 0.1 --mix-ratio 0.2 (2.4 hours, 20% injected)",
          "nohup python run_continuous_mixed.py --scenario high_volume --days 2 > bot.log 2>&1 & (background)",
          "./monitor_bot.sh (monitor running bot)"
        ],
        "how_it_works": [
          "1. Creates PolymarketClient for real API calls",
          "2. Creates InjectionSource for stress scenario",
          "3. Wraps both in MixedMarketProvider",
          "4. Each iteration: fetches real markets + injects N% stress markets",
          "5. Engine processes combined markets (detectors, risk, broker)",
          "6. UnifiedReporter + LiveReporter log all activity",
          "7. Sleeps refresh_seconds, repeats until end_time"
        ],
        "output": [
          "reports/unified_report.json (comprehensive JSON with iterations, opportunities, trades)",
          "reports/live_summary.csv (CSV with iteration-by-iteration deltas)",
          "bot_continuous.log (stdout/stderr when run with nohup)",
          "bot.pid (process ID for monitoring/stopping)"
        ],
        "monitoring": {
          "script": "monitor_bot.sh",
          "commands": [
            "tail -f bot_continuous.log (watch live)",
            "./monitor_bot.sh (status summary)",
            "cat reports/live_summary.csv | column -t -s, (formatted CSV)",
            "python demo_unified_reporting.py (human-readable report)"
          ],
          "stop": "kill $(cat bot.pid)"
        },
        "env_requirements": ["POLYMARKET_API_KEY", "POLYMARKET_SECRET", "POLYMARKET_PASSPHRASE"],
        "notes": [
          "Runs for specified duration, then auto-exits",
          "Combines real market volatility with controlled stress scenarios",
          "Useful for multi-day validation before production deployment",
          "All injected markets prefixed with INJECTED_XXX_ to avoid ID conflicts",
          "Reports accumulate over entire run - analyze after completion"
        ]
      },
      "verification": {
        "entry": "src/predarb/verify_reports.py",
        "cli": "python -m predarb.verify_reports [--report PATH] [--quiet]",
        "description": "Verify unified_report.json structure, completeness, and invariants",
        "arguments": [
          {
            "arg": "--report PATH",
            "default": "reports/unified_report.json",
            "description": "Path to unified report file"
          },
          {
            "arg": "-q, --quiet",
            "description": "Suppress summary output (return exit code only)"
          }
        ],
        "checks": [
          "File exists and readable",
          "Valid JSON with required schema",
          "Metadata section present",
          "At least one iteration recorded",
          "Execution/trade data consistency",
          "Invariants: residual exposure hedged, non-success has hedge, etc."
        ],
        "exit_codes": {
          "0": "OK - all checks passed",
          "2": "Report file missing or unreadable",
          "3": "Invalid schema (malformed JSON or missing keys)",
          "4": "No iterations recorded",
          "5": "Expected executions/trades missing",
          "6": "Invariants failed (hedge/flatten logic violated)"
        },
        "example_commands": [
          "python -m predarb.verify_reports (verify default report)",
          "python -m predarb.verify_reports --report custom/path.json",
          "python -m predarb.verify_reports --quiet (exit code only)",
          "echo $? (check exit code on Unix)",
          "$LASTEXITCODE (check exit code on Windows PowerShell)"
        ],
        "when_to_use": "Post-run validation, CI/CD pipeline checks, debugging report issues"
      },
      "simulation": {
        "entry": "sim_run.py",
        "call": "python sim_run.py",
        "description": "Run bot against FAKE Polymarket client with REAL Telegram notifications",
        "when_to_use": "Test without hitting live API, realistic E2E validation",
        "arguments": [
          {
            "arg": "--days N",
            "default": 5,
            "description": "Simulate N days of market evolution"
          },
          {
            "arg": "--trade-size N",
            "default": 100,
            "description": "Size per trade in USD"
          },
          {
            "arg": "--seed N",
            "default": 42,
            "description": "Random seed for reproducibility"
          },
          {
            "arg": "--markets N",
            "default": 50,
            "description": "Generate N synthetic markets"
          },
          {
            "arg": "--config PATH",
            "description": "Custom config.yml"
          },
          {
            "arg": "--no-telegram",
            "description": "Disable Telegram notifications (mock instead)"
          },
          {
            "arg": "-v/--verbose",
            "description": "Print debug output"
          }
        ],
        "example_flows": [
          "python sim_run.py --days 2 --trade-size 200 (simulate 2 days, $200/trade, real Telegram)",
          "python sim_run.py --days 7 --no-telegram (7-day sim, no Telegram)",
          "python sim_run.py --seed 999 --markets 100 (100 markets, fixed seed)"
        ],
        "how_it_works": [
          "1. Generates synthetic markets (FakePolymarketClient)",
          "2. Engine.run_once() called iteratively (days * iterations per day)",
          "3. Markets evolve minute-by-minute (prices change, trades happen)",
          "4. Detectors run, opportunities detected",
          "5. Broker executes trades (paper trading)",
          "6. TelegramNotifier sends real messages (unless --no-telegram)",
          "7. Final report with P&L, Sharpe ratio, max drawdown"
        ]
      },
      "utilities": [
        {
          "script": "python check_connection.py",
          "purpose": "Test Polymarket API connectivity (GET /markets)"
        },
        {
          "script": "python get_keys.py",
          "purpose": "Retrieve/manage API keys"
        },
        {
          "script": "python analyze_filter_effectiveness.py",
          "purpose": "Analyze filter effectiveness from unified_report.json",
          "output": "Approval rates, rejection analysis, filter recommendations",
          "when_to_use": "After continuous run to diagnose filter performance"
        },
        {
          "script": "python debug_rejections.py",
          "purpose": "Debug why opportunities are rejected by risk manager",
          "output": "Breakdown of rejections by category (edge_too_low, liquidity_too_low, etc.)",
          "when_to_use": "When approval rate is unexpectedly low"
        },
        {
          "script": "python check_continuous_run.py",
          "purpose": "Quick status check for continuous bot run",
          "output": "Latest iteration stats, approval rate, market mix analysis",
          "when_to_use": "Monitor running bot without stopping it"
        },
        {
          "script": "python test_filters_quick.py",
          "purpose": "Fast validation of filter changes with happy_path scenario",
          "output": "Detection and approval counts with comparison to baseline",
          "when_to_use": "After editing config.yml to validate changes"
        },
        {
          "script": "./tune_filters.sh",
          "purpose": "Interactive filter preset selector (relaxed/current/strict/custom)",
          "output": "Updated config.yml with selected preset",
          "when_to_use": "Need to quickly change filter aggressiveness",
          "presets": [
            "RELAXED - min_liquidity_usd: 250, min_net_edge: 0.002, min_volume: 500",
            "CURRENT - min_liquidity_usd: 500, min_net_edge: 0.005, min_volume: 1000",
            "STRICT - min_liquidity_usd: 1000, min_net_edge: 0.01, min_volume: 5000",
            "CUSTOM - opens config.yml in editor"
          ]
        },
          {
            "script": "python -c \"from src.predarb.unified_reporter import read_unified_report; data = read_unified_report(); print(f'Iterations: {len(data.get(\\\"iterations\\\", []))}, Opportunities: {len(data.get(\\\"opportunity_executions\\\", []))}')\"",
            "purpose": "Read and summarize reports/unified_report.json (unified JSON reporting)",
            "notes": "No network calls; replaces legacy CSV reading"
          },
          {
            "script": "python -c \"from src.predarb.unified_reporter import export_legacy_csv; export_legacy_csv()\"",
            "purpose": "Export legacy CSV files from unified_report.json for backward compatibility",
            "notes": "Generates live_summary.csv and paper_trades.csv from unified JSON"
        }
      ]
    },
    "test_commands": {
      "run_all_tests": {
        "cmd": "pytest tests/",
        "description": "Run entire test suite"
      },
      "test_by_category": [
        {
          "category": "Unified Reporting (JSON-based)",
          "cmd": "python -m pytest -q tests/test_unified_reporter.py",
          "coverage": "23 tests covering UnifiedReporter initialization, iteration logging, opportunity execution logging, JSON structure, file safety, legacy export"
        },
        {
          "category": "Legacy Live Reporting (CSV-based, deprecated)",
          "cmd": "python -m pytest -q tests/test_reporter.py",
          "coverage": "10 tests covering initialization, deduplication, state persistence, order-independence, CSV format",
          "note": "Legacy reporter - UnifiedReporter is the current implementation"
        },
        {
          "category": "Engine & Core Logic",
          "cmd": "pytest tests/test_engine.py tests/test_broker.py tests/test_detectors.py -v"
        },
        {
          "category": "Telegram Commands (parsing, auth, routing)",
          "cmd": "pytest tests/test_telegram_interface.py -v",
          "coverage": "27 tests covering command parsing, rate limiting, authorization, handlers"
        },
        {
          "category": "Telegram Notifications (app→user messages)",
          "cmd": "pytest tests/test_telegram_notifier.py -v",
          "note": "Legacy module - use test_simulation_harness.py for modern impl"
        },
        {
          "category": "Simulation & Mocks (FakeClient, TelegramMock)",
          "cmd": "pytest tests/test_simulation_harness.py -v",
          "coverage": "34 tests covering synthetic markets, mock client, notifier mocking"
        },
        {
          "category": "Invariant Tests (comprehensive correctness proofs)",
          "cmd": "pytest tests/test_*_invariants.py -v",
          "coverage": "215+ tests validating market data, filtering, detectors, broker, risk (16 invariants)"
        },
        {
          "category": "Full Suite with Coverage",
          "cmd": "pytest tests/ --cov=src/predarb --cov=arbitrage_bot --cov-report=html"
        }
      ],
      "specific_test_examples": [
        {
          "name": "Run reporter tests (quiet)",
          "cmd": "python -m pytest -q tests/test_reporter.py --junitxml=reports/reporter-tests.xml"
        },
        {
          "name": "Run reporter tests (verbose)",
          "cmd": "python -m pytest tests/test_reporter.py -v"
        },
        {
          "name": "Test command parsing",
          "cmd": "pytest tests/test_telegram_interface.py::TestCommandParser -v"
        },
        {
          "name": "Test rate limiting",
          "cmd": "pytest tests/test_telegram_interface.py::TestRateLimiter -v"
        },
        {
          "name": "Test authorization",
          "cmd": "pytest tests/test_telegram_interface.py::TestAuthorizationGate -v"
        },
        {
          "name": "Test handler logic",
          "cmd": "pytest tests/test_telegram_interface.py::TestTelegramHandlers -v"
        },
        {
          "name": "Test simulation integration",
          "cmd": "pytest tests/test_simulation_harness.py::TestSimulationIntegration -v"
        },
        {
          "name": "Test LLM verification",
          "cmd": "pytest tests/test_llm_verifier.py -v"
        }
      ]
    },
    "llm_verification": {
      "description": "Optional LLM-based verification layer for semantic market clustering. Confirms two markets truly resolve on the same event + criteria.",
      "purpose": "Reduce false positives from embeddings (e.g., 'Fed holds in January' vs 'Fed holds in March')",
      "enabled_by_default": false,
      "configuration": {
        "location": "config.yml under 'llm_verification' section",
        "fields": {
          "enabled": {
            "type": "bool",
            "default": false,
            "description": "Enable/disable LLM verification"
          },
          "provider": {
            "type": "str",
            "default": "mock",
            "options": ["mock", "openai", "gemini"],
            "description": "LLM provider to use. 'mock' for testing (no API calls), 'openai' for GPT-3.5"
          },
          "model": {
            "type": "str",
            "default": "gpt-3.5-turbo",
            "description": "Model name (e.g., 'gpt-3.5-turbo', 'gemini-1.5-flash')"
          },
          "timeout_s": {
            "type": "float",
            "default": 3.0,
            "description": "Timeout per verification call in seconds"
          },
          "max_pairs_per_group": {
            "type": "int",
            "default": 5,
            "description": "Max market pairs to verify per semantic group"
          },
          "min_similarity_to_verify": {
            "type": "float",
            "default": 0.90,
            "description": "Only verify pairs with embedding similarity >= this (0..1)"
          },
          "cache_path": {
            "type": "str",
            "default": "data/llm_verify_cache.json",
            "description": "Path to persistent cache (write-then-rename for safety)"
          },
          "ttl_hours": {
            "type": "int",
            "default": 168,
            "description": "Cache TTL in hours (default: 1 week)"
          },
          "fail_mode": {
            "type": "str",
            "default": "fail_open",
            "options": ["fail_open", "fail_closed"],
            "description": "On timeout/error: 'fail_open'=assume same event, 'fail_closed'=assume different"
          }
        }
      },
      "yaml_example": "llm_verification:\n  enabled: true\n  provider: openai\n  model: gpt-3.5-turbo\n  timeout_s: 3.0\n  max_pairs_per_group: 5\n  fail_mode: fail_open",
      "environment_requirements": {
        "openai_provider": "Set OPENAI_API_KEY env var for GPT-3.5 verification",
        "mock_provider": "No API key needed; deterministic testing"
      },
      "components": {
        "LLMVerifierConfig": {
          "location": "src/predarb/config.py",
          "description": "Configuration Pydantic model with validation"
        },
        "LLMVerifier": {
          "location": "src/predarb/llm_verifier.py",
          "methods": {
            "verify_pair(market_a, market_b)": "Verify if two markets are same event; returns VerificationResult with confidence",
            "verify_group(group)": "Verify all pairs in a market group; uses union-find to split into subgroups"
          }
        },
        "VerificationResult": {
          "description": "Result of verifying two markets",
          "fields": ["same_event (bool)", "confidence (0..1)", "reason (str)", "resolution_source (optional)", "resolution_date (optional)"]
        },
        "LLMProvider": {
          "description": "Abstract interface for LLM backends",
          "implementations": ["OpenAIChatProvider (real API)", "MockLLMProvider (deterministic testing)"]
        }
      },
      "integration": {
        "location": "src/predarb/matchers.py::verify_semantic_groups()",
        "trigger": "After semantic clustering groups markets",
        "input": "Dict[group_id -> List[Market]] from semantic clustering",
        "output": "Dict[group_id -> List[List[Market]]] with verified subgroups",
        "example_usage": "verified = verify_semantic_groups(semantic_groups, llm_verifier=verifier)"
      },
      "caching": {
        "strategy": "Persistent JSON cache with TTL",
        "cache_key": "hash(sorted_market_ids, prompt_version, model_name)",
        "order_invariant": "Pair (a,b) and (b,a) have same cache key",
        "write_safety": "Write to temp file then atomic rename to avoid corruption"
      },
      "testing": {
        "cmd": "pytest tests/test_llm_verifier.py -v",
        "coverage": "34 tests with MockLLMProvider (zero network calls)",
        "test_scenarios": [
          "Same-event detection (Fed January)",
          "Different-event detection (January vs March)",
          "Cache hit prevention of duplicate calls",
          "Timeout with fail_open/fail_closed",
          "JSON parse error handling",
          "Cache persistence and TTL",
          "Group verification with union-find"
        ]
      },
      "production_notes": {
        "cost": "GPT-3.5 ~$0.0005 per call; with caching, typically 1-5 calls per bot run",
        "latency": "~0.5-1.5s per call; timeout_s default is 3.0, non-blocking with fail_open",
        "network_safe": "Timeouts are caught; bot continues if verification unavailable",
        "recommended": "Enable on production clusters; disable (default) for local testing"
      }
    },
    "live_mode": {
      "overview": "ENABLED by PaperBroker (simulation only); TO ENABLE REAL TRADING, requires code modification",
      "current_state": "All trades simulated via PaperBroker (no real capital/blockchain)",
      "simulation_features": [
        "Fee modeling (configurable bps)",
        "Slippage modeling (configurable bps)",
        "Liquidity constraints (depth_fraction)",
        "Position tracking and P&L"
      ],
      "to_enable_real_live": [
        "1. Replace PaperBroker with RealBroker (uses py-clob-client)",
        "2. Add private key management (eth-account)",
        "3. Add risk guardrails (kill switch, position limits)",
        "4. Test on testnet first (chain_id=1)",
        "5. Deploy on mainnet (chain_id=137)"
      ],
      "caution": "⚠️ REAL TRADING REQUIRES: API keys, private keys, significant capital, risk management expertise"
    },
    "server_runbook": {
      "document": "RUNBOOK_SERVER.md",
      "purpose": "Operational steps to stop previously running bots, verify health, and start the new bot on server",
      "stop_previous": {
        "systemd": [
          "sudo systemctl stop arbitrage-bot.service",
          "sudo systemctl disable arbitrage-bot.service (optional)",
          "sudo systemctl status arbitrage-bot.service"
        ],
        "tmux": [
          "tmux ls",
          "tmux kill-session -t arbitrage"
        ],
        "screen": [
          "screen -ls",
          "screen -S arbitrage -X quit"
        ],
        "docker": [
          "docker ps",
          "docker stop arbitrage-bot"
        ],
        "bare_process": [
          "ps aux | grep -E 'python (-m predarb|bot.py)' | grep -v grep",
          "pkill -f 'python -m predarb'",
          "pkill -f 'python bot.py'"
        ]
      },
      "verification": {
        "no_network": [
          ". .venv/bin/activate",
          "python -m predarb selftest",
          "pytest -q tests/test_reporter.py"
        ],
        "optional_network": [
          "python bot.py test_connection --config config.yml"
        ]
      },
      "start_new": {
        "venv_foreground": [
          ". .venv/bin/activate",
          "python -m predarb run --config config.yml"
        ],
        "venv_smoke": [
          "python -m predarb run --config config.yml --iterations 5"
        ],
        "tmux_background": [
          "tmux new -s arbitrage -d '. .venv/bin/activate && python -m predarb run --config config.yml'"
        ],
        "systemd": {
          "unit_path": "/etc/systemd/system/arbitrage-bot.service",
          "unit_template": "See RUNBOOK_SERVER.md",
          "enable_and_start": [
            "sudo systemctl daemon-reload",
            "sudo systemctl enable arbitrage-bot.service",
            "sudo systemctl start arbitrage-bot.service",
            "sudo systemctl status arbitrage-bot.service"
          ]
        }
      },
      "monitoring": {
        "logs": [
          "journalctl -u arbitrage-bot -f (systemd)",
          "tmux attach -t arbitrage (tmux)"
        ],
        "reports": [
          "reports/paper_trades.csv",
          "reports/live_summary.csv"
        ]
      }
    },
    "telegram_integration": {
      "overview": "Bidirectional bot-user communication: OUTBOUND (bot→user notifications) + INBOUND (user→bot commands)",
      "architecture": "Freqtrade-style: Handlers queue actions (non-blocking), bot_loop processes async",
      "enable_telegram": {
        "step_1": "Create Telegram bot via @BotFather (get TELEGRAM_BOT_TOKEN)",
        "step_2": "Find your chat ID (use /tg_info command to find, or use bot getter)",
        "step_3": "Set environment variables or config.yml:",
        "env_vars": {
          "TELEGRAM_ENABLED": "true",
          "TELEGRAM_BOT_TOKEN": "123456789:ABCdefGHIjklmnoPQRstuvWXYZabcdefg",
          "TELEGRAM_CHAT_ID": "987654321"
        },
        "config_yaml": "telegram:\n  enabled: true\n  bot_token: \"${TELEGRAM_BOT_TOKEN}\"\n  chat_id: \"${TELEGRAM_CHAT_ID}\""
      },
      "outbound_messages": {
        "description": "Bot sends these messages to user",
        "notification_features": {
          "status_labels": "🟢 GREAT (edge >= 5%), 🟡 MEDIUM (edge >= 2%), 🔴 BAD (edge < 2%)",
          "market_titles": "Shows market question/title for context (truncated to 80 chars for single market, 60 chars + '+N more' for multiple)",
          "trade_actions": "Displays BUY/SELL sides with 📗 BUY and 📕 SELL emojis plus prices",
          "human_readable_format": "Percentages (38.25%) and dollar gains ($38.25 per $100) instead of raw decimals (0.3825)",
          "market_id_shortening": "Long hashes truncated (0x7130b8d...e2f7df)",
          "enrichment": "Engine enriches opportunities with market_titles from market_lookup before notifying"
        },
        "message_types": [
          {
            "type": "opportunity_detected",
            "trigger": "Arbitrage opportunity detected and approved by risk manager",
            "format": "🔎 Opportunity [TYPE] [STATUS_LABEL]\nMarket: [market_title]\nTrades: 📗 BUY [outcome] @ [price] vs 📕 SELL [outcome] @ [price]\nIDs: [shortened_market_ids]\nEdge: [XX.XX]% (Est. gain: $[XX.XX] per $100)\nDetails: [description]",
            "example": "🔎 Opportunity DUPLICATE 🟢 GREAT\nMarket: Will Bitcoin reach $100,000 by end of 2026?\nTrades: 📗 BUY yes @ 0.385 vs 📕 SELL yes @ 0.003\nIDs: 0x7130b8d...e2f7df, 0x9a23ef1...b4c8da\nEdge: 38.25% (Est. gain: $38.25 per $100)\nDetails: Duplicate: 38.5% vs 0.3% (gap: 38.2%, $38.20/$100)"
          },
          {
            "type": "trade_entered",
            "trigger": "Opportunity executed, position opened",
            "format": "📊 Market: [name]\nOutcomes: [YES/NO]\nSizes: [x units], [y units]\nPrices: [price1], [price2]\nExpected Edge: [%]"
          },
          {
            "type": "trade_exited",
            "trigger": "Position closed, P&L realized",
            "format": "✅ CLOSED\nMarket: [name]\nP&L: $[amount] ([%] return)\nExit Price: [price]"
          },
          {
            "type": "daily_summary",
            "trigger": "End of day or /daily command",
            "format": "📈 Daily Summary\nTotal P&L: $[amount]\nRealized: $[amount]\nUnrealized: $[amount]\nReturn: [%]"
          },
          {
            "type": "status_reply",
            "trigger": "/status command",
            "format": "🤖 Bot Status\nState: [RUNNING/PAUSED/STOPPED]\nMode: [PAPER/LIVE/SCAN_ONLY]\nBalance: $[amount]\nPositions: [count]\nP&L: $[amount]"
          },
          {
            "type": "mode_changed",
            "trigger": "Operating mode changed",
            "format": "🔄 Mode Changed\nPrevious: [old_mode]\nNew: [new_mode]\nTimestamp: [time]"
          },
          {
            "type": "error_alert",
            "trigger": "API error, invalid data, risk violation",
            "format": "❌ ERROR\nMessage: [error_text]\nTimestamp: [time]\nAction: [retry/halt/etc]"
          },
          {
            "type": "risk_warning",
            "trigger": "Kill switch triggered, drawdown exceeded, position limit breached",
            "format": "🚨 CRITICAL - TRADING HALTED\nReason: [kill_switch/drawdown/limit]\nCurrent Loss: [%]\nThreshold: [%]"
          }
        ],
        "testing_outbound": "pytest tests/test_simulation_harness.py::TestTelegramNotifierReal -v"
      },
      "inbound_commands": {
        "description": "User sends /commands to bot, bot processes them",
        "flow": "Parse → RateLimit → Authorize → Queue → Return Response → bot_loop executes async",
        "command_reference": [
          {
            "command": "/start",
            "category": "CONTROL",
            "permission": "execute_action",
            "args": "none",
            "effect": "Start bot (state=RUNNING)",
            "response": "✅ Bot starting...",
            "rate_limit": "5/min (CONTROL)"
          },
          {
            "command": "/pause",
            "category": "CONTROL",
            "permission": "execute_action",
            "args": "none",
            "effect": "Pause bot (state=PAUSED, no new trades)",
            "response": "⏸️ Bot paused",
            "rate_limit": "5/min"
          },
          {
            "command": "/stop",
            "category": "CONTROL",
            "permission": "execute_action",
            "args": "none",
            "effect": "Stop bot (state=STOPPED, exit loop)",
            "response": "⏹️ Bot stopped",
            "rate_limit": "5/min"
          },
          {
            "command": "/status",
            "category": "VIEW",
            "permission": "read_status",
            "args": "none",
            "effect": "Return bot state snapshot",
            "response": "Bot state, mode, balance, positions, P&L",
            "rate_limit": "10/min (VIEW)"
          },
          {
            "command": "/mode [scan-only|paper|live]",
            "category": "DANGEROUS",
            "permission": "execute_action + admin",
            "args": "scan-only, paper, or live",
            "effect": "Change operating mode (requires 2-step confirmation if live)",
            "response": "🔄 Mode changed to [mode]",
            "rate_limit": "2/min (DANGEROUS)",
            "confirmation": true
          },
          {
            "command": "/daily",
            "category": "VIEW",
            "permission": "read_status",
            "args": "none",
            "effect": "Return daily P&L summary",
            "response": "Daily breakdown (realized, unrealized, total return)",
            "rate_limit": "10/min"
          },
          {
            "command": "/balance",
            "category": "VIEW",
            "permission": "read_status",
            "args": "none",
            "effect": "Show current balance and equity",
            "response": "Cash: $[amount], Equity: $[amount]",
            "rate_limit": "10/min"
          },
          {
            "command": "/positions",
            "category": "VIEW",
            "permission": "read_status",
            "args": "none",
            "effect": "List all open positions",
            "response": "Market: [name], Size: [units], Entry: $[price], Unrealized: $[pnl]",
            "rate_limit": "10/min"
          },
          {
            "command": "/freeze [all|venue|event]",
            "category": "CONTROL",
            "permission": "execute_action",
            "args": "all (freeze all trading) or venue/event (specific)",
            "effect": "Stop entering new positions (can still close existing)",
            "response": "🔒 Frozen: [target]",
            "rate_limit": "5/min"
          },
          {
            "command": "/unfreeze [all|venue|event]",
            "category": "CONTROL",
            "permission": "execute_action",
            "args": "all or specific",
            "effect": "Resume entering new positions",
            "response": "🔓 Unfrozen: [target]",
            "rate_limit": "5/min"
          },
          {
            "command": "/forceclose [all|market_id]",
            "category": "DANGEROUS",
            "permission": "execute_action + admin",
            "args": "all (close all positions) or market_id (close specific)",
            "effect": "Immediately close positions (2-step confirmation required)",
            "response": "🔴 Closed [count] positions, realized P&L: $[amount]",
            "rate_limit": "2/min",
            "confirmation": true
          },
          {
            "command": "/help",
            "category": "VIEW",
            "permission": "read_status",
            "args": "none",
            "effect": "Show command help",
            "response": "List of available commands with descriptions",
            "rate_limit": "10/min"
          },
          {
            "command": "/confirm [code]",
            "category": "CONFIRMATION",
            "permission": "execute_action",
            "args": "6-digit confirmation code (received from dangerous command)",
            "effect": "Verify and execute dangerous command",
            "response": "✅ Confirmed. Action executing..." or "❌ Invalid code",
            "rate_limit": "20/min"
          },
          {
            "command": "/tg_info",
            "category": "DEBUG",
            "permission": "read_status",
            "args": "none",
            "effect": "Echo chat_id and user_id (helps with setup)",
            "response": "Your chat_id: [id], user_id: [id]",
            "rate_limit": "10/min"
          },
          {
            "command": "/health",
            "category": "VIEW",
            "permission": "read_status",
            "args": "none",
            "effect": "Check API connectivity and system health",
            "response": "API: ✅ OK, Memory: [usage], Uptime: [duration]",
            "rate_limit": "10/min"
          },
          {
            "command": "/opps",
            "category": "DEBUG",
            "permission": "read_status",
            "args": "none",
            "effect": "List current detected opportunities",
            "response": "Found [count] opportunities:\n[detector]: [market] - edge [%]",
            "rate_limit": "10/min"
          }
        ],
        "testing_inbound": "pytest tests/test_telegram_interface.py -v"
      },
      "security_features": {
        "authorization": [
          "Chat ID validation (must match TELEGRAM_CHAT_ID config)",
          "Role-based access control (read_status, execute_action, admin)",
          "VIEW commands: anyone with read_status",
          "CONTROL commands: requires execute_action",
          "DANGEROUS commands: requires execute_action + admin + 2-step confirmation"
        ],
        "confirmation": [
          "Dangerous commands (/mode live, /forceclose) require 2-step confirmation",
          "Command sends confirmation code (e.g., /confirm ABC123)",
          "User replies /confirm ABC123 to execute",
          "Code expires after 5 minutes (configurable)",
          "Each code is single-use"
        ],
        "rate_limiting": [
          "VIEW commands: 10/min per user",
          "CONTROL commands: 5/min per user",
          "DANGEROUS commands: 2/min per user",
          "CONFIRMATION: 20/min per user",
          "Global command queue prevents spam"
        ],
        "message_safety": [
          "Numbers formatted as strings (prevent precision loss)",
          "Markdown special chars escaped (prevent injection)",
          "Message length limited to 4096 (Telegram limit)",
          "User input sanitized",
          "All actions logged for audit trail"
        ]
      },
      "configuration": {
        "file": "config.yml",
        "section": "telegram",
        "schema": {
          "enabled": "bool (default: false)",
          "bot_token": "str (required if enabled, from @BotFather)",
          "chat_id": "int (required if enabled, your chat ID)",
          "auth": {
            "users": [
              {
                "user_id": "int",
                "roles": ["read_status", "execute_action", "admin"]
              }
            ]
          },
          "rate_limits": {
            "view": "int (commands/min, default: 10)",
            "control": "int (default: 5)",
            "dangerous": "int (default: 2)"
          }
        },
        "example_config": {
          "yaml": "telegram:\n  enabled: true\n  bot_token: \"${TELEGRAM_BOT_TOKEN}\"\n  chat_id: \"${TELEGRAM_CHAT_ID}\"\n  auth:\n    users:\n      - user_id: 123456789\n        roles: [read_status, execute_action, admin]\n  rate_limits:\n    view: 10\n    control: 5\n    dangerous: 2"
        }
      },
      "testing": {
        "mock_notifier": {
          "class": "TelegramNotifierMock",
          "location": "src/predarb/testing/",
          "purpose": "In-memory message storage (no HTTP calls)",
          "usage": "Engine(..., notifier=TelegramNotifierMock())",
          "benefits": [
            "No Telegram API credentials needed",
            "Deterministic (no network)",
            "Fast (no API latency)",
            "Inspectable (get_messages(), has_message_containing())"
          ]
        },
        "test_outbound": "pytest tests/test_simulation_harness.py::TestTelegramNotifierMock -v",
        "test_inbound": "pytest tests/test_telegram_interface.py -v",
        "full_integration": "pytest tests/test_simulation_harness.py::TestSimulationIntegration -v"
      }
    },
    "workflow_examples": {
      "example_1_quick_test": {
        "goal": "Quick test without hitting live API",
        "steps": [
          "python -m predarb selftest",
          "Runs against fixtures, exits in <5 seconds",
          "Output: validation results, no Telegram/API calls"
        ]
      },
      "example_2_single_iteration": {
        "goal": "Run one full iteration (detect & trade)",
        "setup": [
          "Set POLYMARKET_API_KEY, SECRET, PASSPHRASE env vars",
          "Configure config.yml (risk, filters, detectors)",
          "Optional: set TELEGRAM_ENABLED=true for notifications"
        ],
        "run": "python -m predarb once",
        "output": [
          "Fetches active markets from Polymarket API",
          "Runs detectors",
          "Executes trades (paper broker simulates)",
          "Logs results + sends Telegram notification",
          "Writes to reports/paper_trades.csv"
        ]
      },
      "example_3_continuous_run": {
        "goal": "Run bot indefinitely (production mode)",
        "setup": "Same as example_2",
        "run": "python -m predarb run",
        "output": [
          "Continuous loop: fetch markets → detect → trade → sleep → repeat",
          "Sleep duration: config.engine.refresh_seconds (default: 60)",
          "All trades logged to CSV",
          "All opportunities sent to Telegram (if enabled)",
          "Monitor via /status command (if Telegram configured)"
        ]
      },
      "example_4_simulation": {
        "goal": "Test against fake market data with real Telegram notifications",
        "setup": [
          "Optional: Set TELEGRAM env vars for real notifications",
          "No Polymarket credentials needed (uses FakePolymarketClient)"
        ],
        "run": "python sim_run.py --days 5 --trade-size 200",
        "output": [
          "Generates 50 synthetic markets (or --markets N)",
          "Simulates 5 days of market evolution",
          "Runs engine repeatedly (detects & executes trades)",
          "Sends real Telegram notifications (or --no-telegram for mock)",
          "Final report: P&L, Sharpe ratio, max drawdown, trade count"
        ]
      },
      "example_5_telegram_control": {
        "goal": "Monitor and control bot via Telegram",
        "prerequisites": [
          "Bot running (python -m predarb run &)",
          "Telegram configured and enabled",
          "TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID set"
        ],
        "commands": [
          "User: /status",
          "Bot: 🤖 Bot Status\nState: RUNNING\nMode: PAPER\nBalance: $10000\nPositions: 3\nP&L: $245.67",
          "",
          "User: /daily",
          "Bot: 📈 Daily Summary\nTotal P&L: $245.67\nRealized: $120.00\nUnrealized: $125.67\nReturn: 2.46%",
          "",
          "User: /freeze all (requires execute_action role)",
          "Bot: 🔒 Frozen: all\n(bot stops entering new trades)",
          "",
          "User: /mode live (requires 2-step confirmation)",
          "Bot: 🔐 Confirm with /confirm ABC123\n(user replies /confirm ABC123)",
          "Bot: ✅ Confirmed. Mode changed to LIVE"
        ]
      }
    },
    "configuration_reference": {
      "file": "config.yml",
      "sections": {
        "polymarket": [
          "host: API endpoint (default: https://clob.polymarket.com)",
          "api_key: CLOB API key",
          "secret: CLOB secret",
          "passphrase: CLOB passphrase",
          "private_key: Ethereum private key (for signing)",
          "chain_id: Network (default: 137 = Polygon mainnet)",
          "funder: Funder wallet address"
        ],
        "broker": [
          "initial_cash: Starting capital for paper trading ($10000 default)",
          "fee_bps: Fee in basis points (10 = 0.1%, default: 10)",
          "slippage_bps: Slippage modeling (20 = 0.2%, default: 20)",
          "depth_fraction: Liquidity fraction available (0.05 = 5% depth, default: 0.05)"
        ],
        "risk": [
          "max_allocation_per_market: Max % of capital per position (default: 5%)",
          "max_open_positions: Max concurrent open positions (default: 10)",
          "min_liquidity_usd: Minimum market liquidity to trade ($100 default)",
          "min_net_edge_threshold: Minimum profitability threshold (0.01 = 1%, default: 0.01)",
          "kill_switch_drawdown: Max portfolio drawdown before halt (0.5 = 50%, default: 0.5)"
        ],
        "engine": [
          "refresh_seconds: Sleep between iterations (60 default)",
          "iterations: Max number of runs (-1 = infinite, default: -1)",
          "report_path: CSV output path (default: reports/paper_trades.csv)"
        ],
        "filter": [
          "max_spread_pct: Max price spread % (0.1 = 10%, default: 0.1)",
          "min_volume_24h: Min trading volume ($1000 default)",
          "min_liquidity: Min market liquidity USD ($500 default)",
          "min_days_to_expiry: Min days until market closes (1 default)",
          "require_resolution_source: Must have resolution source (true default)",
          "min_rank_score: Min composite market score (0.5 default)",
          "spread_score_weight: Weight in ranking (0.3 default)",
          "volume_score_weight: Weight in ranking (0.35 default)",
          "liquidity_score_weight: Weight in ranking (0.35 default)"
        ],
        "detectors": [
          "parity_threshold: Min outcomes sum (0.99 default)",
          "duplicate_price_diff_threshold: Max price diff between clones (0.05 = 5%, default: 0.05)",
          "exclusive_sum_tolerance: Tolerance for exclusive sum check (0.01 default)",
          "ladder_tolerance: Tolerance for ladder detection (0.02 default)",
          "timelag_price_jump: Min price jump for timelag (0.05 default)",
          "timelag_persistence_minutes: How long timelag persists (10 default)"
        ],
        "telegram": [
          "enabled: Enable notifications (false default)",
          "bot_token: Telegram bot token (from @BotFather)",
          "chat_id: Telegram chat ID (your personal chat ID)",
          "auth: User roles and permissions",
          "rate_limits: Commands per minute by risk level"
        ]
      }
    },
    "module_map": {
      "core_engine": {
        "file": "src/predarb/engine.py",
        "class": "Engine",
        "entry": "run() or run_once()",
        "orchestrates": [
          "PolymarketClient.get_active_markets()",
          "FilterMarkets.filter_markets()",
          "Detector pipeline (6 detectors)",
          "RiskManager.check_limits()",
          "PaperBroker.execute(opportunity)",
          "Notifier.send_message()"
        ]
      },
      "detectors": {
        "location": "src/predarb/detectors/",
        "pattern": "class XyzDetector: def detect(markets) → List[Opportunity]",
        "detectors": [
          "ParityDetector - outcomes don't sum to 1",
          "LadderDetector - sequential outcome prices",
          "DuplicateDetector - clone markets, price divergence",
          "ExclusiveSumDetector - mutually exclusive check",
          "TimeLagDetector - stale prices",
          "ConsistencyDetector - cross-market validation",
          "CompositeDetector - hierarchical event relationships (added 2026-01-09)"
        ]
      },
      "config": {
        "location": "src/predarb/config.py",
        "classes": [
          "AppConfig - root config",
          "PolymarketConfig - API settings",
          "BrokerConfig - trading params",
          "RiskConfig - risk limits",
          "FilterConfig - market filtering",
          "DetectorConfig - detector thresholds",
          "TelegramConfig - notifications",
          "EngineConfig - engine loop"
        ]
      },
      "models": {
        "location": "src/predarb/models.py",
        "classes": [
          "Market - pydantic model for market data",
          "Outcome - pydantic model for outcomes",
          "Opportunity - dataclass for detected arb",
          "Trade - dataclass for executed trade",
          "TradeAction - dataclass for single trade component"
        ]
      },
      "broker": {
        "location": "src/predarb/broker.py",
        "class": "PaperBroker",
        "simulates": "Trade execution (fees, slippage, liquidity constraints)",
        "tracks": "Positions, P&L, equity, cash balance"
      },
      "notifier": {
        "location": "src/predarb/notifiers/",
        "base": "Notifier (abstract)",
        "implementations": [
          "TelegramNotifierReal - sends to Telegram API",
          "TelegramNotifierMock - in-memory (testing)"
        ]
      },
      "telegram_bot": {
        "location": "arbitrage_bot/",
        "components": [
          "main.py - TelegramControlledArbitrageBot orchestrator",
          "core/bot_loop.py - async execution loop",
          "core/control_queue.py - command queue",
          "core/state.py - bot state snapshot",
          "core/actions.py - action dataclasses",
          "telegram/router.py - command parsing & routing",
          "telegram/handlers.py - command handlers",
          "telegram/security.py - auth, confirmation, formatting",
          "telegram/rate_limit.py - rate limiting"
        ]
      },
      "stress_testing": {
        "injection": {
          "location": "src/predarb/injection.py",
          "classes": [
            "MarketProvider (Protocol) - interface for real/injected clients",
            "InjectionSource - factory for creating providers from specs",
            "FileMarketProvider - load markets from JSON file",
            "InlineMarketProvider - parse markets from inline JSON string"
          ],
          "purpose": "Enable network-free testing with deterministic market data"
        },
        "scenarios": {
          "location": "src/predarb/stress_scenarios.py",
          "classes": [
            "StressScenario (base class) - seeded scenario generation",
            "HighVolumeScenario - 1000 markets (performance test)",
            "ManyRiskRejectionsScenario - 40 markets (risk validation test)",
            "PartialFillScenario - 10 markets (hedge logic test)",
            "HappyPathScenario - 15 markets (success case test)",
            "LatencyFreshnessScenario - 15 markets (expiry validation test)",
            "FeeSlippageScenario - 20 markets (cost modeling test)",
            "SemanticClusteringScenario - 25 markets (semantic clustering + filter test)"
          ],
          "functions": [
            "get_scenario(name, seed) - get scenario by name",
            "list_scenarios() - list available scenario names"
          ],
          "purpose": "Built-in stress test scenarios for comprehensive pipeline testing"
        },
        "verification": {
          "location": "src/predarb/verify_reports.py",
          "classes": [
            "ReportVerifier - verify unified_report.json structure and invariants"
          ],
          "functions": [
            "verify_reports(report_path, verbose) - verify and return exit code",
            "main() - CLI entry point"
          ],
          "exit_codes": {
            "EXIT_OK": 0,
            "EXIT_MISSING": 2,
            "EXIT_INVALID_SCHEMA": 3,
            "EXIT_NO_ITERATIONS": 4,
            "EXIT_MISSING_DATA": 5,
            "EXIT_INVARIANT_FAILED": 6
          },
          "purpose": "Validate reports and return meaningful exit codes for CI/CD"
        }
      }
    },
    "environment_variables": {
      "polymarket_credentials": [
        "POLYMARKET_API_KEY (required)",
        "POLYMARKET_SECRET (required)",
        "POLYMARKET_PASSPHRASE (required)",
        "POLYMARKET_PRIVATE_KEY (optional, for signing)",
        "POLYMARKET_FUNDER (optional, wallet address)"
      ],
      "telegram": [
        "TELEGRAM_ENABLED (true/false, default: false)",
        "TELEGRAM_BOT_TOKEN (required if enabled)",
        "TELEGRAM_CHAT_ID (required if enabled)"
      ],
      "setup": [
        "Create .env file in root directory",
        "Add KEY=VALUE pairs",
        "python-dotenv automatically loads"
      ],
      "example_env": "POLYMARKET_API_KEY=your_key\nPOLYMARKET_SECRET=your_secret\nPOLYMARKET_PASSPHRASE=your_pass\nTELEGRAM_ENABLED=true\nTELEGRAM_BOT_TOKEN=123:ABC...\nTELEGRAM_CHAT_ID=987654321"
    },
    "output_files": {
      "unified_report": {
        "path": "reports/unified_report.json",
        "purpose": "Single JSON file containing all reporting data (iterations + opportunity executions)",
        "format": "JSON with two top-level arrays",
        "structure": {
          "iterations": [
            {
              "iteration": "int - iteration number",
              "timestamp": "ISO 8601 timestamp",
              "markets_count": "int - total markets processed",
              "opportunities_detected": "int - opportunities found",
              "opportunities_approved": "int - opportunities passing risk checks",
              "approval_rate": "float - approved/detected ratio",
              "status": "str - iteration status (e.g., 'complete')"
            }
          ],
          "opportunity_executions": [
            {
              "opportunity_id": "str - unique opportunity identifier",
              "timestamp": "ISO 8601 timestamp",
              "iteration": "int - which iteration detected this",
              "detector": "str - detector name",
              "markets": "list of market identifiers",
              "actions": "list of trade actions executed",
              "status": "str - execution status",
              "pnl": "float - profit/loss if applicable"
            }
          ]
        },
        "write_safety": "Atomic write (temp file then rename) prevents corruption",
        "api": {
          "report_iteration(iteration, markets_count, opps_detected, opps_approved, status)": "Log iteration summary",
          "log_opportunity_execution(opp_id, detector, markets, actions, status, pnl)": "Log opportunity execution",
          "log_trades(trades_list)": "Log multiple trades at once"
        },
        "migration_from_legacy": "Replaces live_summary.csv + opportunity_logs.jsonl with single JSON file",
        "backward_compatibility": "Use export_legacy_csv() to generate old CSV files from unified JSON"
      },
      "legacy_csv_trades": {
        "path": "reports/paper_trades.csv",
        "purpose": "Legacy CSV log of executed trades (can be exported from unified_report.json)",
        "status": "DEPRECATED - Use unified_report.json instead",
        "columns": [
          "timestamp",
          "market_id",
          "outcome_id",
          "side",
          "amount",
          "price",
          "fees",
          "slippage",
          "realized_pnl"
        ],
        "export_function": "export_legacy_csv() in unified_reporter.py"
      },
      "legacy_live_reporting": {
        "path": "reports/live_summary.csv",
        "purpose": "Legacy CSV summary (can be exported from unified_report.json)",
        "status": "DEPRECATED - Use unified_report.json instead",
        "columns": [
          "TIMESTAMP","READABLE_TIME","ITERATION","MARKETS","MARKETS_Δ","DETECTED","DETECTED_Δ","APPROVED","APPROVED_Δ","APPROVAL%","STATUS","MARKET_HASH","OPP_HASH"
        ],
        "export_function": "export_legacy_csv() in unified_reporter.py"
      },
      "reporter_junit": {
        "path": "reports/reporter-tests.xml",
        "purpose": "JUnit XML from reporter tests (for CI visibility)"
      },
      "logs": {
        "destination": "stdout",
        "format": "[timestamp] [level] [module]: [message]",
        "level": "DEBUG, INFO, WARNING, ERROR"
      },
      "telegram_messages": {
        "destination": "Telegram chat (if enabled)",
        "types": "trade_entered, trade_exited, daily_summary, status_reply, error_alert, risk_warning"
      }
    },
    "dependencies": {
      "core": [
        "requests - HTTP client",
        "pydantic - data validation",
        "pyyaml - YAML parsing",
        "python-dotenv - env loading"
      ],
      "trading": [
        "py-clob-client - Polymarket API",
        "eth-account - Ethereum signing",
        "python-dateutil - date parsing"
      ],
      "notifications": [
        "python-telegram-bot - Telegram integration"
      ],
      "testing": [
        "pytest - test framework",
        "pytest-asyncio - async test support"
      ]
    },
    "quick_reference": {
      "start_quick_test": "python -m predarb selftest",
      "start_once": "python -m predarb once (requires API creds)",
      "start_production": "python -m predarb run (infinite loop)",
      "start_simulation": "python sim_run.py --days 5",
      "start_stress_test": "python -m predarb stress --scenario happy_path",
      "start_stress_heavy": "python -m predarb stress --scenario high_volume --iterations 10",
      "start_stress_semantic": "python -m predarb stress --scenario semantic_clustering",
      "start_dual_stress": "python -m predarb dual-stress --cross-venue",
      "start_strict_ab_validation": "python -m predarb validate-ab --seed 42",
      "test_strict_ab_simple": "python test_strict_ab_validator.py",
      "test_strict_ab_full": "python validate_strict_ab_mode.py",
      "demo_testing": "python demo_testing_visual.py (visual guide to all scenarios)",
      "demo_rebalancing": "python demo_rebalancing_guide.py (rebalancing walkthrough)",
      "demo_semantic": "python demo_semantic_clustering.py (semantic clustering demo)",
      "verify_reports": "python -m predarb.verify_reports",
      "run_tests": "pytest tests/ (34/36 tests passing as of 2026-01-07)",
      "run_stress_tests": "pytest tests/test_injection.py tests/test_stress_scenarios.py tests/test_verify_reports.py -v",
      "enable_telegram": "Set TELEGRAM_ENABLED=true, bot_token, chat_id",
      "view_unified_report": "cat reports/unified_report.json | python -m json.tool",
      "export_legacy_csv": "python -c 'from src.predarb.unified_reporter import export_legacy_csv; export_legacy_csv()'",
      "read_report_summary": "python -c 'from src.predarb.unified_reporter import read_unified_report; print(read_unified_report())'",
      "check_api": "python check_connection.py",
      "telegram_commands": "/start /pause /stop /status /daily /mode /freeze /unfreeze /forceclose /help",
      "rate_limits": "VIEW: 10/min, CONTROL: 5/min, DANGEROUS: 2/min",
      "confirmation": "Dangerous commands need 2-step: command → code → /confirm code",
      "test_status": "34/36 tests passing (94% success rate)",
      "stress_scenarios": "high_volume, many_risk_rejections, partial_fill, happy_path, latency_freshness, fee_slippage"
    }
  }
}
